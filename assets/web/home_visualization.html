<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Home 3D Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            display: none;
            z-index: 100;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 18px;
        }
        
        /* ============ UNIFIED TOP NAVBAR ============ */
        #main-navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(180deg, rgba(30, 30, 40, 0.95), rgba(20, 20, 30, 0.95));
            border-bottom: 2px solid rgba(100, 100, 100, 0.4);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            z-index: 1001;
            box-sizing: border-box;
        }
        
        .navbar-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .navbar-section.left {
            flex: 0 0 auto;
        }
        
        .navbar-section.center {
            flex: 1;
            justify-content: center;
        }
        
        .navbar-section.right {
            flex: 0 0 auto;
        }
        
        .navbar-title {
            color: #FFD700;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            white-space: nowrap;
        }
        
        .navbar-divider {
            width: 1px;
            height: 35px;
            background: rgba(255, 255, 255, 0.2);
            margin: 0 10px;
        }
        
        /* Navbar Buttons */
        .nav-btn {
            width: 44px;
            height: 44px;
            background: linear-gradient(145deg, #3a3a4a, #2a2a3a);
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 20px;
            color: white;
            position: relative;
        }
        
        .nav-btn:hover {
            background: linear-gradient(145deg, #4a4a5a, #3a3a4a);
            border-color: #FFD700;
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.3);
            transform: translateY(-2px);
        }
        
        .nav-btn.active {
            background: linear-gradient(145deg, #FFD700, #E6C200);
            border-color: #FFD700;
            color: #333;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        
        .nav-btn-small {
            width: 36px;
            height: 36px;
            font-size: 16px;
        }
        
        /* Info Display in Navbar */
        .navbar-info {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 0 15px;
            color: white;
            font-size: 14px;
        }
        
        .navbar-info-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .navbar-info-item .icon {
            font-size: 16px;
        }
        
        .navbar-info-item .value {
            font-weight: bold;
        }
        
        .navbar-info-item.time .value {
            color: #FFD700;
        }
        
        .navbar-info-item.temp .value {
            color: #FF6B6B;
        }
        
        /* ============ DROPDOWN PANELS ============ */
        .dropdown-panel {
            position: absolute;
            top: 65px;
            background: rgba(30, 30, 40, 0.95);
            border: 2px solid rgba(100, 100, 100, 0.5);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
            display: none;
            z-index: 1002;
            min-width: 200px;
        }
        
        .dropdown-panel.active {
            display: block;
        }
        
        .dropdown-panel.left {
            left: 15px;
        }
        
        .dropdown-panel.right {
            right: 15px;
        }
        
        .dropdown-panel.center {
            left: 50%;
            transform: translateX(-50%);
        }
        
        .dropdown-title {
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .dropdown-section {
            margin-bottom: 12px;
        }
        
        .dropdown-section label {
            display: block;
            font-size: 11px;
            color: #aaa;
            margin-bottom: 6px;
            text-transform: uppercase;
        }
        
        .dropdown-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        
        .dropdown-btn {
            padding: 8px 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s ease;
            text-align: center;
        }
        
        .dropdown-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
        }
        
        .dropdown-btn.active {
            background: #4CAF50;
            border-color: #4CAF50;
        }
        
        /* Color Picker Panel */
        #color-picker-panel {
            min-width: 180px;
        }
        
        .color-picker-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .color-picker-row input[type="color"] {
            width: 50px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            cursor: pointer;
            background: transparent;
        }
        
        .color-picker-row input[type="text"] {
            flex: 1;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: white;
            font-size: 12px;
            font-family: monospace;
        }
        
        /* Day/Night Slider Panel */
        #daynight-panel {
            min-width: 250px;
        }
        
        .time-slider-container {
            padding: 10px 0;
        }
        
        .time-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #1a1a3a, #FFD700, #87CEEB, #FFD700, #1a1a3a);
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }
        
        .time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            border: 2px solid #FFD700;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        
        .time-display {
            text-align: center;
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            margin-top: 10px;
        }
        
        .auto-time-toggle {
            margin-top: 12px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            cursor: pointer;
            width: 100%;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .auto-time-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .auto-time-toggle.active {
            background: rgba(76, 175, 80, 0.4);
            border-color: #4CAF50;
        }

        /* Hide old panels - keeping for JS compatibility */
        #theme-panel, #navigation-controls, #selected-mesh-color-panel, .panel-mini-btn, #minecraft-hud {
            display: none !important;
        }
        
        /* ============ MOBILE DRAWER NAVIGATION ============ */
        #mobile-menu-btn {
            display: none;
            width: 44px;
            height: 44px;
            background: linear-gradient(145deg, #3a3a4a, #2a2a3a);
            border: 2px solid #555;
            border-radius: 10px;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            transition: all 0.2s ease;
        }
        
        #mobile-menu-btn:hover {
            background: linear-gradient(145deg, #4a4a5a, #3a3a4a);
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }
        
        /* Mobile Drawer Overlay */
        #drawer-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #drawer-overlay.active {
            display: block;
            opacity: 1;
        }
        
        /* Mobile Drawer Panel */
        #mobile-drawer {
            position: fixed;
            top: 0;
            right: -320px;
            width: 300px;
            max-width: 85vw;
            height: 100vh;
            background: linear-gradient(180deg, #1a1a2e, #16213e, #0f0f23);
            z-index: 2000;
            transition: right 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            box-shadow: -5px 0 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        
        .drawer-content {
            flex: 1 1 auto;
            height: 0;
            min-height: 0;
            overflow-y: scroll !important;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            padding: 0 0 60px 0;
        }
        
        #mobile-drawer.active {
            right: 0;
        }
        
        .drawer-header {
            flex-shrink: 0;
            padding: 20px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 215, 0, 0.05));
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .drawer-title {
            color: #FFD700;
            font-size: 22px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .drawer-close {
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .drawer-close:hover {
            background: rgba(255, 100, 100, 0.3);
            border-color: #ff6b6b;
            transform: rotate(90deg);
        }
        
        .drawer-section {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .drawer-section-title {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 12px;
            font-weight: 600;
        }
        
        .drawer-item {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 14px 16px;
            margin: 6px 0;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 15px;
        }
        
        .drawer-item:hover {
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.3);
            transform: translateX(5px);
        }
        
        .drawer-item.active {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.1));
            border-color: #FFD700;
        }
        
        .drawer-item-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .drawer-item.active .drawer-item-icon {
            background: linear-gradient(145deg, #FFD700, #E6C200);
        }
        
        .drawer-item-text {
            flex: 1;
        }
        
        .drawer-item-arrow {
            color: #666;
            font-size: 14px;
        }
        
        .drawer-info-bar {
            display: flex;
            gap: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            margin-top: 10px;
        }
        
        .drawer-info-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-size: 14px;
        }
        
        .drawer-info-item .icon {
            font-size: 18px;
        }
        
        .drawer-info-item.time .value {
            color: #FFD700;
            font-weight: bold;
        }
        
        .drawer-info-item.temp .value {
            color: #FF6B6B;
            font-weight: bold;
        }
        
        /* Drawer sub-sections and controls */
        .drawer-subsection {
            padding: 10px 0;
        }
        
        .drawer-label {
            color: #aaa;
            font-size: 12px;
            margin-bottom: 8px;
        }
        
        .drawer-btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .drawer-btn-grid.cols-2 {
            grid-template-columns: 1fr 1fr;
        }
        
        .drawer-btn {
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: white;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        
        .drawer-btn:hover, .drawer-btn:active {
            background: rgba(255, 215, 0, 0.15);
            border-color: rgba(255, 215, 0, 0.4);
        }
        
        .drawer-btn.active {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.25), rgba(255, 215, 0, 0.15));
            border-color: #FFD700;
            color: #FFD700;
        }
        
        .drawer-btn.full-width {
            grid-column: 1 / -1;
        }
        
        .drawer-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
            margin: 10px 0;
        }
        
        .drawer-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: linear-gradient(145deg, #FFD700, #E6C200);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .drawer-time-display {
            text-align: center;
            font-size: 28px;
            font-weight: bold;
            color: #FFD700;
            margin: 10px 0;
        }
        
        .drawer-color-row {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        
        .drawer-color-input {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
        }
        
        .drawer-color-input::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        
        .drawer-color-input::-webkit-color-swatch {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
        }
        
        .drawer-hex-input {
            flex: 1;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-family: monospace;
        }
        
        .drawer-hex-input:focus {
            outline: none;
            border-color: #FFD700;
        }
        
        /* ============ TOAST NOTIFICATION ============ */
        #toast-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3000;
            pointer-events: none;
        }
        
        .toast {
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.95), rgba(20, 20, 30, 0.95));
            border: 1px solid rgba(255, 215, 0, 0.4);
            border-radius: 12px;
            padding: 12px 20px;
            color: white;
            font-size: 14px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* ============ FLOATING PAINT PICKER (Mobile) ============ */
        #floating-paint-picker {
            position: fixed;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2500;
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.98), rgba(20, 20, 30, 0.98));
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 16px;
            padding: 16px 20px;
            display: none;
            flex-direction: column;
            gap: 12px;
            min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
        }
        
        #floating-paint-picker.visible {
            display: flex;
        }
        
        .floating-paint-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .floating-paint-title {
            color: white;
            font-size: 14px;
            font-weight: 600;
        }
        
        .floating-paint-close {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .floating-paint-close:hover {
            background: rgba(255, 100, 100, 0.3);
        }
        
        .floating-paint-mesh {
            color: #FFD700;
            font-size: 13px;
            padding: 8px 12px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 8px;
        }
        
        .floating-paint-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .floating-color-picker {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
            padding: 0;
        }
        
        .floating-color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        
        .floating-color-picker::-webkit-color-swatch {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
        }
        
        .floating-hex-input {
            flex: 1;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-family: monospace;
        }
        
        .floating-hex-input:focus {
            outline: none;
            border-color: #FFD700;
        }
        
        .floating-paint-apply {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }
        
        .floating-paint-apply:active {
            transform: scale(0.98);
        }
        
        .floating-paint-exit {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }
        
        .floating-paint-exit:hover, .floating-paint-exit:active {
            background: rgba(231, 76, 60, 0.3);
            border-color: rgba(231, 76, 60, 0.5);
        }
        
        /* ============ MOBILE RESPONSIVE STYLES ============ */
        @media screen and (max-width: 768px) {
            /* Hide desktop navbar center buttons on mobile */
            #main-navbar .navbar-section.center {
                display: none;
            }
            
            #main-navbar {
                height: 56px;
                padding: 0 12px;
            }
            
            /* Show mobile menu button */
            #mobile-menu-btn {
                display: flex;
            }
            
            .navbar-title {
                font-size: 16px;
            }
            
            .navbar-divider {
                display: none;
            }
            
            .dropdown-panel {
                display: none !important; /* Use drawer instead */
            }
        }
        
        @media screen and (max-width: 480px) {
            #main-navbar {
                height: 52px;
                padding: 0 10px;
            }
            
            .navbar-title {
                font-size: 14px;
            }
            
            #mobile-menu-btn {
                width: 40px;
                height: 40px;
                font-size: 22px;
            }
            
            #mobile-drawer {
                width: 280px;
            }
        }
        
        /* ============ SELECTION PANEL FOR INTERACTIVE ELEMENTS ============ */
        #selection-panel {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(180deg, rgba(30, 30, 40, 0.95), rgba(20, 20, 30, 0.95));
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 12px;
            padding: 15px 20px;
            z-index: 1003;
            display: none;
            min-width: 200px;
            max-width: 320px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
        }
        
        #selection-panel.active {
            display: block;
        }
        
        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .selection-title {
            color: #FFD700;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .selection-close {
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .selection-close:hover {
            background: rgba(255, 100, 100, 0.3);
            border-color: rgba(255, 100, 100, 0.6);
        }
        
        .selection-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .selection-btn {
            padding: 12px 16px;
            background: linear-gradient(145deg, #3a3a4a, #2a2a3a);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.2s ease;
        }
        
        .selection-btn:hover {
            background: linear-gradient(145deg, #4a4a5a, #3a3a4a);
            border-color: #FFD700;
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.3);
        }
        
        .selection-btn.primary {
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            border-color: #4CAF50;
        }
        
        .selection-btn.primary:hover {
            background: linear-gradient(145deg, #66BB6A, #43A047);
            box-shadow: 0 0 12px rgba(76, 175, 80, 0.5);
        }
        
        .selection-btn.danger {
            background: linear-gradient(145deg, #f44336, #d32f2f);
            border-color: #f44336;
        }
        
        .selection-btn.danger:hover {
            background: linear-gradient(145deg, #ef5350, #e53935);
            box-shadow: 0 0 12px rgba(244, 67, 54, 0.5);
        }
        
        .selection-btn .btn-icon {
            font-size: 18px;
        }
        
        .selection-status {
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 12px;
            color: #aaa;
            text-align: center;
        }
        
        .selection-status.open {
            color: #4CAF50;
        }
        
        .selection-status.closed {
            color: #FF9800;
        }
        
        .theme-section {
            margin-bottom: 12px;
        }
        
        .theme-section label {
            display: block;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 6px;
            opacity: 0.9;
        }
        
        .theme-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        
        .theme-btn {
            padding: 8px 10px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s ease;
            display: block;
            width: 100%;
            text-align: center;
        }
        
        .theme-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.8);
            transform: scale(1.02);
        }
        
        .theme-btn.active {
            background: #4CAF50;
            border-color: #45a049;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.6);
        }
        
        .toggle-btn {
            padding: 8px 10px;
            border: none;
            border-radius: 4px;
            background: rgba(76, 175, 80, 0.6);
            color: white;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            width: 100%;
            transition: all 0.2s ease;
        }
        
        .toggle-btn:hover {
            background: rgba(76, 175, 80, 0.8);
        }
        
        /* Minimized panel button */
        .panel-mini-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(76, 175, 80, 0.6);
            border-radius: 6px;
            color: white;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s ease;
            z-index: 1000;
        }
        
        .panel-mini-btn:hover {
            background: rgba(0, 0, 0, 0.95);
            border-color: #4CAF50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }
        
        #theme-panel.minimized ~ .panel-mini-btn {
            display: flex;
        }
        
        /* Color picker for selected mesh */
        #selected-mesh-color-panel {
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid rgba(76, 175, 80, 0.5);
            display: none;
            z-index: 999;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
        }
        
        #selected-mesh-color-panel.active {
            display: block;
        }
        
        .mesh-name-display {
            font-size: 12px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(76, 175, 80, 0.3);
            font-weight: bold;
        }
        
        .color-picker-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .color-picker-group input[type="color"] {
            width: 50px;
            height: 40px;
            border: 2px solid rgba(76, 175, 80, 0.5);
            border-radius: 4px;
            cursor: pointer;
        }
        
        .color-picker-group input[type="text"] {
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.4);
            border-radius: 4px;
            color: white;
            font-size: 11px;
            font-family: monospace;
            width: 100px;
        }
        
        /* Navigation Controls */
        #navigation-controls {
            position: absolute;
            top: 10px;
            left: 65px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid rgba(76, 175, 80, 0.5);
            border-radius: 8px;
            padding: 8px;
            z-index: 999;
            display: flex;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
        }
        
        #navigation-controls.minimized .nav-content {
            display: none;
        }
        
        #navigation-controls.minimized {
            padding: 8px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .nav-label {
            font-size: 28px;
            font-weight: bold;
            color: #4CAF50;
            text-align: center;
            margin: 0;
        }
        
        .nav-minimize-btn {
            display: none;
        }
        
        .nav-minimize-btn:hover {
            background: rgba(76, 175, 80, 0.6);
            box-shadow: 0 0 6px rgba(76, 175, 80, 0.5);
        }
        
        .nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }
        
        .nav-content {
            transition: all 0.3s ease;
        }
        
        .nav-arrows {
            display: grid;
            grid-template-columns: 35px 35px 35px;
            grid-template-rows: 30px 30px 30px;
            gap: 3px;
        }
        
        .nav-btn {
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid rgba(76, 175, 80, 0.6);
            border-radius: 3px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            padding: 0;
        }
        
        .nav-btn:hover {
            background: rgba(76, 175, 80, 0.6);
            border-color: #4CAF50;
            box-shadow: 0 0 6px rgba(76, 175, 80, 0.5);
        }
        
        .nav-btn:active {
            background: rgba(76, 175, 80, 0.8);
            box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.5);
        }
        
        .nav-btn.forward {
            grid-column: 2;
            grid-row: 1;
        }
        
        .nav-btn.left {
            grid-column: 1;
            grid-row: 2;
        }
        
        .nav-btn.back {
            grid-column: 2;
            grid-row: 3;
        }
        
        .nav-btn.right {
            grid-column: 3;
            grid-row: 2;
        }
        
        #navigation-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid rgba(76, 175, 80, 0.5);
            border-radius: 8px;
            padding: 8px;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
        }
        
        #navigation-controls.minimized .nav-content {
            display: none;
        }
        
        #navigation-controls.minimized {
            padding: 6px;
            min-width: auto;
        }
        /* Navbar-style Control Panel */
        #minecraft-hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1001;
            font-family: 'Arial', sans-serif;
            user-select: none;
            transition: all 0.3s ease;
        }
        
        #minecraft-hud.minimized .hud-panel-content {
            display: none;
        }
        
        #minecraft-hud.minimized .hud-panel {
            height: auto;
            padding: 8px 15px;
        }
        
        .hud-panel {
            background: linear-gradient(180deg, rgba(40, 40, 50, 0.95), rgba(25, 25, 35, 0.95));
            border: none;
            border-bottom: 2px solid rgba(100, 100, 100, 0.5);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            border-radius: 0;
            padding: 10px 20px;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            box-sizing: border-box;
        }
        
        .hud-panel-header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            gap: 0;
            flex-shrink: 0;
        }
        
        .hud-title {
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.8);
            margin: 0;
            border: none;
            padding: 0;
        }
        
        .hud-minimize-btn {
            display: none;
        }
        
        .hud-minimize-btn:hover {
            background: rgba(255, 215, 0, 0.4);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }
        
        .hud-panel-content {
            transition: all 0.3s ease;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 15px;
            flex: 1;
            justify-content: center;
        }
        
        .hud-slot-container {
            display: flex;
            flex-direction: row;
            gap: 8px;
            margin: 0;
            justify-content: center;
            flex-wrap: nowrap;
            align-items: center;
        }
        
        .hud-slot {
            width: 42px;
            height: 42px;
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            border: 2px solid #555;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s ease;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.8), 0 2px 5px rgba(0, 0, 0, 0.5);
            position: relative;
            font-size: 20px;
            user-select: none;
        }
        
        .hud-slot:hover {
            background: linear-gradient(145deg, #4a4a4a, #3a3a3a);
            border-color: #FFD700;
            box-shadow: inset 0 0 5px rgba(255, 215, 0, 0.2), 0 0 10px rgba(255, 215, 0, 0.4);
        }
        
        .hud-slot.active {
            background: linear-gradient(145deg, #FFD700, #FFC700);
            border-color: #FFD700;
            color: #333;
            box-shadow: inset 0 0 5px rgba(255, 215, 0, 0.8), 0 0 15px rgba(255, 215, 0, 0.6);
        }
        
        .hud-slot-label {
            position: absolute;
            bottom: -18px;
            font-size: 9px;
            color: #aaa;
            white-space: nowrap;
            text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.8);
        }
        
        .navbar-info {
            display: flex;
            align-items: center;
            padding: 0 15px;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        
        .hud-info-bar {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border: 1px solid #555;
            border-radius: 1px;
            padding: 8px;
            margin-bottom: 8px;
            font-size: 11px;
            color: #ccc;
            text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.8);
        }
        
        .hud-info-label {
            color: #FFD700;
            font-weight: bold;
            font-size: 10px;
            text-transform: uppercase;
            margin-bottom: 2px;
        }
        
        .hud-progress-bar {
            width: 100%;
            height: 8px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 1px;
            overflow: hidden;
            box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.8);
        }
        
        .hud-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00FF00, #00DD00);
            width: 100%;
            transition: width 0.2s ease;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.6);
        }
        
        .hud-button {
            width: 100%;
            padding: 6px;
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            border: 2px solid #555;
            border-radius: 1px;
            color: #ddd;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.8);
            transition: all 0.1s ease;
            margin-top: 4px;
        }
        
        .hud-button:hover {
            background: linear-gradient(145deg, #4a4a4a, #3a3a3a);
            border-color: #FFD700;
            color: #FFD700;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.4);
        }
        
        .hud-button:active {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.8);
        }
        
        .hud-stack-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0, 0, 0, 0.8);
            color: #FFD700;
            font-size: 10px;
            font-weight: bold;
            padding: 1px 3px;
            border: 1px solid #555;
            border-radius: 1px;
        }
        
        /* Mesh Color Customizer Panel */
        #mesh-color-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 1000;
            min-width: 240px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(100, 150, 255, 0.5);
            display: block !important;
            visibility: visible !important;
            max-height: 500px;
            overflow-y: auto;
            transition: all 0.3s ease;
        }
        
        #mesh-color-panel.minimized {
            max-height: 50px;
            padding: 10px 15px;
            overflow: hidden;
            min-width: auto;
        }
        
        #mesh-color-panel.minimized .mesh-color-section {
            display: none;
        }
        
        #mesh-color-panel h3 {
            margin: 0;
            font-size: 14px;
            font-weight: bold;
            border-bottom: 1px solid rgba(100, 150, 255, 0.3);
            padding-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .mesh-minimize-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            cursor: pointer;
            width: 28px;
            height: 28px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
            padding: 0;
        }
        
        .mesh-minimize-btn:hover {
            background: rgba(100, 150, 255, 0.6);
            border-color: rgba(100, 150, 255, 1);
        }
        
        .mesh-color-section {
            margin-top: 12px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        .mesh-color-section label {
            display: block;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 6px;
            opacity: 0.9;
        }
        
        .color-input-group {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        
        .color-input-group input[type="color"] {
            width: 40px;
            height: 32px;
            border: 2px solid rgba(100, 150, 255, 0.5);
            border-radius: 4px;
            cursor: pointer;
        }
        
        .color-input-group input[type="text"] {
            flex: 1;
            padding: 6px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 4px;
            color: white;
            font-size: 11px;
            font-family: monospace;
        }
        
        .color-input-group input[type="text"]:focus {
            outline: none;
            border-color: rgba(100, 150, 255, 0.8);
            background: rgba(255, 255, 255, 0.15);
        }
        
        .reset-color-btn {
            padding: 4px 8px;
            background: rgba(100, 150, 255, 0.4);
            border: 1px solid rgba(100, 150, 255, 0.6);
            color: white;
            cursor: pointer;
            border-radius: 3px;
            font-size: 10px;
            transition: all 0.2s ease;
        }
        
        .reset-color-btn:hover {
            background: rgba(100, 150, 255, 0.6);
            border-color: rgba(100, 150, 255, 1);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="info">Click on rooms to control devices</div>
    <div class="loading" id="loading">Loading 3D Model...</div>
    <div id="toast-container"></div>
    
    <!-- ============ FLOATING PAINT PICKER (Mobile) ============ -->
    <div id="floating-paint-picker">
        <div class="floating-paint-header">
            <span class="floating-paint-title">üé® Paint Mode</span>
            <button class="floating-paint-close" id="floating-paint-close">√ó</button>
        </div>
        <div class="floating-paint-mesh" id="floating-mesh-name">No object selected</div>
        <div class="floating-paint-controls">
            <input type="color" class="floating-color-picker" id="floating-color-picker" value="#ff0000">
            <input type="text" class="floating-hex-input" id="floating-hex-input" placeholder="#ff0000" value="#ff0000">
        </div>
        <button class="floating-paint-apply" id="floating-paint-apply">
            <span>üñåÔ∏è</span> Apply Color
        </button>
        <button class="floating-paint-exit" id="floating-paint-exit">
            <span>üö´</span> Exit Paint Mode
        </button>
    </div>

    <!-- ============ UNIFIED TOP NAVBAR ============ -->
    <div id="main-navbar">
        <!-- Left Section: Title -->
        <div class="navbar-section left">
            <span class="navbar-title">üè† Smart Home</span>
        </div>
        
        <!-- Center Section: Control Buttons (Desktop only) -->
        <div class="navbar-section center">
            <div class="nav-btn active" data-tool="paint" title="Paint Tool">üé®</div>
            <div class="nav-btn" data-tool="theme" title="Theme Settings">üé≠</div>
            <div class="nav-btn" data-tool="light" title="Light Control">üí°</div>
            <div class="nav-btn" data-tool="doors" title="Toggle Door">üö™</div>
            <div class="nav-btn" data-tool="garage" title="Toggle Garage">üöó</div>
            <div class="nav-btn" data-tool="windows" title="Toggle Windows">ü™ü</div>
            <div class="nav-btn" data-tool="daynight" title="Day/Night Cycle">üåÖ</div>
            <div class="nav-btn" data-tool="reset" title="Reset Colors">‚Ü∫</div>
            
            <div class="navbar-divider"></div>
            
            <!-- Info Display -->
            <div class="navbar-info">
                <div class="navbar-info-item time">
                    <span class="icon">üïê</span>
                    <span class="value" id="navbar-time">--:--</span>
                </div>
                <div class="navbar-info-item temp">
                    <span class="icon">üå°Ô∏è</span>
                    <span class="value" id="temp-display"><span id="temp-value">22</span><span id="temp-unit">¬∞C</span></span>
                </div>
            </div>
        </div>
        
        <!-- Right Section: Settings (Desktop) + Mobile Menu -->
        <div class="navbar-section right">
            <div class="nav-btn nav-btn-small" data-tool="settings" title="Settings">‚öôÔ∏è</div>
            <button id="mobile-menu-btn" title="Menu">‚ò∞</button>
        </div>
    </div>
    
    <!-- ============ MOBILE DRAWER ============ -->
    <div id="drawer-overlay"></div>
    <div id="mobile-drawer">
        <div class="drawer-header">
            <div class="drawer-title">üè† Controls</div>
            <button class="drawer-close" id="drawer-close">‚úï</button>
        </div>
        
        <div class="drawer-content">
            <div class="drawer-section">
                <div class="drawer-section-title">Quick Info</div>
                <div class="drawer-info-bar">
                    <div class="drawer-info-item time">
                        <span class="icon">üïê</span>
                        <span class="value" id="drawer-time">--:--</span>
                    </div>
                    <div class="drawer-info-item temp">
                        <span class="icon">üå°Ô∏è</span>
                        <span class="value" id="drawer-temp">22¬∞C</span>
                    </div>
                </div>
            </div>
            
            <!-- Theme Section with Sub-panel -->
            <div class="drawer-section">
                <div class="drawer-section-title">üé≠ Theme & Appearance</div>
                <div class="drawer-subsection">
                    <div class="drawer-label">Color Palette</div>
                    <div class="drawer-btn-grid">
                        <button class="drawer-btn active" data-theme="modern">Modern</button>
                        <button class="drawer-btn" data-theme="classic">Classic</button>
                        <button class="drawer-btn" data-theme="minimal">Minimal</button>
                        <button class="drawer-btn" data-theme="vibrant">Vibrant</button>
                    </div>
                </div>
                <div class="drawer-subsection">
                    <div class="drawer-label">Lighting</div>
                    <div class="drawer-btn-grid">
                        <button class="drawer-btn active" data-lighting="bright">‚òÄÔ∏è Bright</button>
                        <button class="drawer-btn" data-lighting="normal">üå§Ô∏è Normal</button>
                        <button class="drawer-btn" data-lighting="dim">üåô Dim</button>
                    </div>
                </div>
                <div class="drawer-subsection">
                    <button class="drawer-btn full-width" id="drawer-toggle-shadows">‚òÄÔ∏è Shadows: ON</button>
                </div>
            </div>
            
            <!-- Day/Night Section with Slider -->
            <div class="drawer-section">
                <div class="drawer-section-title">üåÖ Day/Night Cycle</div>
                <div class="drawer-subsection">
                    <div class="drawer-time-display" id="drawer-time-display">12:00</div>
                    <input type="range" class="drawer-slider" id="drawer-time-slider" min="0" max="24" step="0.5" value="12">
                    <button class="drawer-btn full-width" id="drawer-auto-time">üïê Auto Time: ON</button>
                </div>
            </div>
            
            <!-- Paint Section -->
            <div class="drawer-section">
                <div class="drawer-section-title">üé® Paint Objects</div>
                <div class="drawer-subsection">
                    <button class="drawer-btn full-width" id="drawer-enable-paint-mode">üé® Enable Paint Mode</button>
                    <div class="drawer-paint-info" id="drawer-paint-info" style="display:none; margin-top: 12px;">
                        <div class="drawer-label">Selected: <span id="drawer-mesh-name">None</span></div>
                        <div class="drawer-color-row">
                            <input type="color" id="drawer-color-picker" value="#ff4444" class="drawer-color-input">
                            <input type="text" id="drawer-hex-input" placeholder="#ff4444" maxlength="7" class="drawer-hex-input">
                            <button class="drawer-btn" id="drawer-apply-color">Apply</button>
                        </div>
                    </div>
                    <button class="drawer-btn full-width" id="drawer-reset-colors" style="margin-top: 10px;">‚Ü∫ Reset All Colors</button>
                </div>
            </div>
            
            <!-- Home Controls Section -->
            <div class="drawer-section">
                <div class="drawer-section-title">üè† Home Controls</div>
                <div class="drawer-btn-grid cols-2">
                    <button class="drawer-btn" id="drawer-toggle-lights">üí° Lights</button>
                    <button class="drawer-btn" id="drawer-toggle-door">üö™ Door</button>
                    <button class="drawer-btn" id="drawer-toggle-garage">üöó Garage</button>
                    <button class="drawer-btn" id="drawer-toggle-windows">ü™ü Windows</button>
                </div>
            </div>
            
            <!-- View Controls Section -->
            <div class="drawer-section">
                <div class="drawer-section-title">üì∑ View Options</div>
                <div class="drawer-btn-grid cols-2">
                    <button class="drawer-btn" id="drawer-reset-camera">üéØ Reset View</button>
                    <button class="drawer-btn" id="drawer-toggle-grid">üìê Grid</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- ============ DROPDOWN PANELS ============ -->
    
    <!-- Theme Panel Dropdown -->
    <div id="theme-dropdown" class="dropdown-panel left">
        <div class="dropdown-title">üé≠ Theme Settings</div>
        <div class="dropdown-section">
            <label>Color Palette</label>
            <div class="dropdown-buttons">
                <button class="dropdown-btn active" data-theme="modern">Modern</button>
                <button class="dropdown-btn" data-theme="classic">Classic</button>
                <button class="dropdown-btn" data-theme="minimal">Minimal</button>
                <button class="dropdown-btn" data-theme="vibrant">Vibrant</button>
            </div>
        </div>
        <div class="dropdown-section">
            <label>Lighting</label>
            <div class="dropdown-buttons">
                <button class="dropdown-btn active" data-lighting="bright">Bright</button>
                <button class="dropdown-btn" data-lighting="normal">Normal</button>
                <button class="dropdown-btn" data-lighting="dim">Dim</button>
            </div>
        </div>
        <div class="dropdown-section">
            <button class="dropdown-btn" id="toggle-shadows" style="width: 100%;">‚òÄÔ∏è Shadows: ON</button>
        </div>
    </div>
    
    <!-- Color Picker Dropdown -->
    <div id="color-picker-panel" class="dropdown-panel left">
        <div class="dropdown-title">üé® Paint Object</div>
        <div id="selected-mesh-name" style="color: #aaa; font-size: 12px; margin-bottom: 10px;">Click an object to paint</div>
        <div class="color-picker-row">
            <input type="color" id="selected-mesh-color-input" value="#ff4444">
            <input type="text" id="selected-mesh-hex-input" placeholder="#ff4444" maxlength="7">
        </div>
    </div>
    
    <!-- Day/Night Panel Dropdown -->
    <div id="daynight-panel" class="dropdown-panel center">
        <div class="dropdown-title">üåÖ Day/Night Cycle</div>
        <div class="time-slider-container">
            <input type="range" class="time-slider" id="time-slider" min="0" max="24" step="0.5" value="12">
        </div>
        <div class="time-display" id="time-display">12:00</div>
        <button class="auto-time-toggle active" id="auto-time-toggle">üïê Auto Time: ON</button>
    </div>
    
    <!-- Settings Panel Dropdown -->
    <div id="settings-dropdown" class="dropdown-panel right">
        <div class="dropdown-title">‚öôÔ∏è Settings</div>
        <div class="dropdown-section">
            <label>View Controls</label>
            <div class="dropdown-buttons" style="grid-template-columns: 1fr;">
                <button class="dropdown-btn" id="reset-camera">üîÑ Reset Camera</button>
                <button class="dropdown-btn" id="toggle-grid">üìê Toggle Grid</button>
            </div>
        </div>
    </div>

    <!-- Selection Panel for Doors/Garages/Windows -->
    <div id="selection-panel">
        <div class="selection-header">
            <div class="selection-title">
                <span id="selection-icon">üö™</span>
                <span id="selection-name">Door</span>
            </div>
            <button class="selection-close" id="selection-close">‚úï</button>
        </div>
        <div class="selection-actions" id="selection-actions">
            <!-- Actions dynamically populated -->
        </div>
        <div class="selection-status" id="selection-status">Status: Closed</div>
    </div>

    <!-- Old panels hidden but kept for JS compatibility -->
    <div id="navigation-controls" style="display:none;"></div>
    <div id="theme-panel" style="display:none;"></div>
    <div id="selected-mesh-color-panel" style="display:none;"></div>
    <div id="minecraft-hud" style="display:none;"></div>

    <!-- Three.js from CDN - ES Module approach -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // Import Three.js modules
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Theme Configuration
        const themes = {
            modern: {
                name: 'Modern Wood',
                colors: {
                    yard: 0x7CCD7C,      // Light grass green
                    home: 0xDEB887,      // Burlywood (light wood)
                    roof: 0x8B4513,      // Saddle brown
                    door: 0xCD853F,      // Peru (wooden door)
                    glass: 0xADD8E6,     // Light cyan
                    garage: 0xA0522D     // Sienna (wood)
                },
                emissive: 0x222222,
                emissiveIntensity: 0.1
            },
            classic: {
                name: 'Classic Cabin',
                colors: {
                    yard: 0x90EE90,      // Light green grass
                    home: 0x8B4513,      // Saddle brown (dark wood)
                    roof: 0x5D3A1A,      // Dark brown wood
                    door: 0xB8860B,      // Dark goldenrod
                    glass: 0x87CEEB,     // Sky blue
                    garage: 0x654321     // Dark brown
                },
                emissive: 0x111111,
                emissiveIntensity: 0.05
            },
            minimal: {
                name: 'Modern White',
                colors: {
                    yard: 0x98FB98,      // Pale green
                    home: 0xFAF0E6,      // Linen white
                    roof: 0x2F4F4F,      // Dark slate gray
                    door: 0x4169E1,      // Royal blue
                    glass: 0xB0E0E6,     // Powder blue
                    garage: 0x696969     // Dim gray
                },
                emissive: 0x111111,
                emissiveIntensity: 0.05
            },
            vibrant: {
                name: 'Colorful',
                colors: {
                    yard: 0x32CD32,      // Lime green
                    home: 0xFFB347,      // Pastel orange
                    roof: 0xDC143C,      // Crimson
                    door: 0xFFD700,      // Gold
                    glass: 0x00CED1,     // Turquoise
                    garage: 0x9370DB     // Medium purple
                },
                emissive: 0x222222,
                emissiveIntensity: 0.15
            }
        };

        const lightingPresets = {
            bright: { ambientIntensity: 1.4, directionalIntensity: 1.7, pointIntensity: 1.0 },
            normal: { ambientIntensity: 1.2, directionalIntensity: 1.5, pointIntensity: 0.8 },
            dim: { ambientIntensity: 0.8, directionalIntensity: 1.0, pointIntensity: 0.5 }
        };

        // Scene setup
        let scene, camera, renderer, controls;
        let homeModel;
        let raycaster, mouse;
        let roomMeshes = {};
        let alarmMeshes = {};
        let ambientLight, directionalLight, pointLight1, pointLight2;
        let currentTheme = 'modern';
        let currentLighting = 'bright';
        let shadowsEnabled = true;
        let gridHelper = null;
        let gridVisible = false;
        let meshColorOverrides = {}; // Store color overrides for individual meshes
        
        // Day/Night cycle variables
        let sunLight = null;
        let moonLight = null;
        let sunMesh = null;
        let moonMesh = null;
        let skyDome = null;
        let groundPlane = null;
        let isAutoTimeEnabled = true;
        let manualTimeOfDay = 12; // 0-24 hours
        let dayNightSpeed = 1; // Multiplier for time progression

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera
            camera = new THREE.PerspectiveCamera(
                60, // Good FOV for 3D view
                window.innerWidth / window.innerHeight,
                0.1,
                2000
            );
            // Position camera to see house nicely
            const isMobile = window.innerWidth <= 768;
            // Mobile: closer view, Desktop: slightly further
            camera.position.set(18, 12, 22);
            camera.lookAt(0, 2, 0);

            // Renderer - Optimized for mobile
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Smooth but performant
            renderer.shadowMap.enabled = true;
            
            const canvas = renderer.domElement;
            canvas.style.touchAction = 'none'; // Prevent default touch behaviors
            document.getElementById('canvas-container').appendChild(canvas);

            // Controls - Standard OrbitControls with zoom enabled
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableRotate = true;
            controls.enableZoom = true;
            controls.enablePan = true;
            controls.target.set(0, 2, 0);
            
            // Speeds
            controls.rotateSpeed = 0.5;
            controls.zoomSpeed = 1.2;  // Faster zoom
            controls.panSpeed = 0.8;   // Faster pan for free movement
            
            // NO zoom limits - unlimited zoom in/out
            controls.minDistance = 0;
            controls.maxDistance = Infinity;
            
            // NO vertical angle limits - full freedom
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = Math.PI;
            
            // Enable free panning in screen space
            controls.screenSpacePanning = true;
            
            // Allow target to move freely when panning
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            console.log('üéÆ Controls: UNLIMITED zoom, rotation, pan enabled');

            // Lights - Much brighter for better visibility
            ambientLight = new THREE.AmbientLight(0xffffff, 1.4); // Bright preset
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1.7); // Bright preset
            directionalLight.position.set(15, 25, 15);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Additional point lights for better illumination
            pointLight1 = new THREE.PointLight(0xffffff, 1.0, 100); // Bright preset
            pointLight1.position.set(-20, 15, -20);
            scene.add(pointLight1);
            
            pointLight2 = new THREE.PointLight(0xffffff, 1.0, 100); // Bright preset
            pointLight2.position.set(20, 15, 20);
            scene.add(pointLight2);
            
            // Raycaster for interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Grid helper (hidden by default, toggled via UI)
            gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x888888);
            gridHelper.visible = false;
            scene.add(gridHelper);
            
            // Initialize theme UI after a brief delay to ensure DOM is ready
            setTimeout(initializeThemeUI, 100);

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onMouseClick);

            // Load model or create placeholder
            loadHomeModel();
            
            // Initialize day/night cycle with real time
            initializeDayNightCycle();
            updateDayNightCycle();

            // Animation loop
            animate();
        }

        function loadHomeModel() {
            // Try to load the GLB model directly for standalone preview
            const loader = new GLTFLoader();
            const modelPath = 'home_model.glb';
            
            console.log('üè† Attempting to load model from:', modelPath);
            
            loader.load(
                modelPath,
                (gltf) => {
                    console.log('‚úÖ Model loaded successfully for standalone preview');
                    if (homeModel) {
                        scene.remove(homeModel);
                    }
                    homeModel = gltf.scene;
                    
                    // Center and scale the model
                    const box = new THREE.Box3().setFromObject(homeModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 10 / maxDim;
                    
                    homeModel.scale.setScalar(scale);
                    homeModel.position.sub(center.multiplyScalar(scale));
                    homeModel.position.y = 0;
                    
                    // Track yard level for ground plane
                    let yardLevel = 0;
                    
                    // Extract room meshes for interaction (same as loadModelFromBase64)
                    homeModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            if (child.name) {
                                console.log('Found mesh:', child.name);
                                
                                // Clone material for independent control
                                if (child.material) {
                                    child.material = child.material.clone();
                                    
                                    // Apply woody theme colors
                                    const nameLower = child.name.toLowerCase();
                                    if (nameLower.includes('yard') || nameLower.includes('ground') || nameLower.includes('grass')) {
                                        child.material.color.setHex(0x7CCD7C); // Light grass green
                                    } else if (nameLower.includes('wall') || nameLower.includes('body') || nameLower.includes('level') || nameLower.includes('home')) {
                                        child.material.color.setHex(0xDEB887); // Burlywood
                                    } else if (nameLower.includes('roof')) {
                                        child.material.color.setHex(0x8B4513); // Saddle brown
                                    } else if (nameLower.includes('door') && !nameLower.includes('garage')) {
                                        child.material.color.setHex(0xCD853F); // Peru
                                    } else if (nameLower.includes('glass') || nameLower.includes('window')) {
                                        child.material.color.setHex(0xADD8E6); // Light blue
                                    } else if (nameLower.includes('garage')) {
                                        child.material.color.setHex(0xA0522D); // Sienna
                                    }
                                    
                                    // Natural emissive
                                    if (child.material.emissive) {
                                        child.material.emissive.setHex(0x222222);
                                        child.material.emissiveIntensity = 0.1;
                                    }
                                }
                                
                                // Store mesh for interaction
                                roomMeshes[child.name] = child;
                                
                                // Store original position and rotation for animations
                                child.userData.originalPosition = child.position.clone();
                                child.userData.originalRotation = child.rotation.clone();
                                
                                // Track yard level
                                if (child.name.toLowerCase().includes('yard')) {
                                    const childBox = new THREE.Box3().setFromObject(child);
                                    yardLevel = childBox.min.y;
                                    console.log('üìç Yard level detected at:', yardLevel);
                                }
                                
                                // Store original color
                                if (child.material && child.material.color) {
                                    child.userData.originalColor = child.material.color.clone();
                                }
                            }
                        }
                    });
                    
                    console.log('üì¶ Extracted meshes:', Object.keys(roomMeshes));
                    
                    // Update ground plane to yard level
                    if (groundPlane) {
                        groundPlane.position.y = yardLevel - 0.01;
                        console.log('üìç Ground plane set to yard level:', yardLevel);
                    }
                    
                    scene.add(homeModel);
                    document.getElementById('loading').style.display = 'none';
                },
                (progress) => {
                    console.log('üì¶ Loading progress:', (progress.loaded / progress.total * 100).toFixed(1) + '%');
                },
                (error) => {
                    console.log('‚ö†Ô∏è Could not load GLB directly, using placeholder. Error:', error.message);
                    console.log('‚è≥ Waiting for Flutter to send .glb model...');
                    createPlaceholderHouse();
                    document.getElementById('loading').style.display = 'none';
                }
            );
        }

        // Load 3D model from base64 string (called from Flutter)
        function loadModelFromBase64(base64String) {
            try {
                console.log('üì¶ Received base64 model from Flutter');
                console.log('üìä Base64 length:', base64String.length);
                
                // Convert base64 to binary
                const binaryString = atob(base64String);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                console.log('üîÑ Creating blob from binary data...');
                const blob = new Blob([bytes], { type: 'model/gltf-binary' });
                const url = URL.createObjectURL(blob);
                
                console.log('üöÄ Loading model with GLTFLoader...');
                const loader = new GLTFLoader();
                loader.load(
                    url,
                    function(gltf) {
                        // Remove placeholder if it exists
                        if (roomMeshes['living_room']) {
                            Object.values(roomMeshes).forEach(mesh => {
                                scene.remove(mesh);
                            });
                            roomMeshes = {};
                        }
                        
                        homeModel = gltf.scene;
                        
                        // CRITICAL FIX: Scale up the model significantly
                        homeModel.scale.set(100, 100, 100); // Scale 100x
                        
                        scene.add(homeModel);
                        
                        console.log('‚úÖ 3D Model loaded successfully from base64!');
                        console.log('üìè Model scaled to:', homeModel.scale);
                        
                        // Calculate bounding box to understand model size
                        const box = new THREE.Box3().setFromObject(homeModel);
                        const size = box.getSize(new THREE.Vector3());
                        const center = box.getCenter(new THREE.Vector3());
                        
                        console.log('üì¶ Model size:', size);
                        console.log('üìç Model center:', center);
                        
                        // Position camera to view the entire model
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const fov = camera.fov * (Math.PI / 180);
                        let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                        cameraZ *= 1.5; // Add some padding
                        
                        camera.position.set(cameraZ, cameraZ * 0.7, cameraZ);
                        camera.lookAt(center);
                        
                        // Update controls target to model center
                        controls.target.copy(center);
                        controls.update();
                        
                        console.log('üé• Camera positioned at:', camera.position);
                        console.log('üéØ Camera looking at:', center);
                        
                        // Extract room meshes and door for interaction
                        homeModel.traverse((child) => {
                            if (child.isMesh && child.name) {
                                console.log('Found mesh:', child.name);
                                
                                // IMPORTANT: Clone the material so each mesh has its own independent material
                                // This prevents materials from being shared between meshes
                                if (child.material) {
                                    child.material = child.material.clone();
                                    console.log('Cloned material for:', child.name);
                                }
                                
                                // Store all meshes
                                roomMeshes[child.name] = child;
                                
                                // Apply color adjustments based on mesh name (woody theme)
                                if (child.material) {
                                    // Yard/ground meshes - light grass green
                                    if (child.name.toLowerCase().includes('yard') || 
                                        child.name.toLowerCase().includes('ground') ||
                                        child.name.toLowerCase().includes('grass')) {
                                        child.material.color.setHex(0x7CCD7C); // Light grass green
                                    }
                                    // House walls and structure - burlywood (light wood)
                                    else if (child.name.toLowerCase().includes('home') || 
                                             child.name.toLowerCase().includes('wall') ||
                                             child.name.toLowerCase().includes('body') ||
                                             child.name.toLowerCase().includes('level')) {
                                        child.material.color.setHex(0xDEB887); // Burlywood
                                    }
                                    // Roof - saddle brown
                                    else if (child.name.toLowerCase().includes('roof')) {
                                        child.material.color.setHex(0x8B4513); // Saddle brown
                                    }
                                    // Door - peru (wooden door)
                                    else if (child.name.toLowerCase().includes('door') && !child.name.toLowerCase().includes('garage')) {
                                        child.material.color.setHex(0xCD853F); // Peru
                                        console.log('Applied door color to:', child.name);
                                    }
                                    // Glass/windows - light cyan blue
                                    else if (child.name.toLowerCase().includes('glass') || 
                                             child.name.toLowerCase().includes('window')) {
                                        child.material.color.setHex(0xADD8E6); // Light blue glass
                                    }
                                    // Garage - sienna (wood)
                                    else if (child.name.toLowerCase().includes('garage')) {
                                        child.material.color.setHex(0xA0522D); // Sienna
                                        console.log('Applied garage color to:', child.name);
                                    }
                                    
                                    // Lower emissive for more natural look
                                    if (child.material.emissive) {
                                        child.material.emissive.setHex(0x222222);
                                        child.material.emissiveIntensity = 0.1;
                                    }
                                    
                                    // Store original color for reset
                                    if (child.material.color) {
                                        child.userData.originalColor = child.material.color.clone();
                                    }
                                    // Store original position for animations
                                    child.userData.originalPosition = child.position.clone();
                                    child.userData.originalRotation = child.rotation.clone();
                                }
                            }
                        });
                        
                        console.log('üì¶ Extracted meshes:', Object.keys(roomMeshes));
                        
                        // Clean up blob URL
                        URL.revokeObjectURL(url);
                    },
                    function(xhr) {
                        const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                        console.log(percent + '% loaded');
                    },
                    function(error) {
                        console.error('‚ùå Error loading model from base64:', error);
                        console.log('‚ö†Ô∏è Keeping placeholder house');
                        URL.revokeObjectURL(url);
                    }
                );
            } catch (error) {
                console.error('‚ùå Error processing base64 model:', error);
                console.log('‚ö†Ô∏è Keeping placeholder house');
            }
        }

        function createPlaceholderHouse() {
            // Create a simple house structure as placeholder
            const rooms = [
                { name: 'living_room', x: 0, z: 0, width: 6, depth: 6, color: 0x8ab4f8 },
                { name: 'kitchen', x: 7, z: 0, width: 4, depth: 6, color: 0xfbc02d },
                { name: 'bedroom', x: 0, z: 7, width: 5, depth: 5, color: 0xe1bee7 },
                { name: 'garage', x: 7, z: 7, width: 4, depth: 5, color: 0x90a4ae },
            ];

            rooms.forEach(room => {
                const geometry = new THREE.BoxGeometry(room.width, 3, room.depth);
                const material = new THREE.MeshPhongMaterial({
                    color: room.color,
                    transparent: true,
                    opacity: 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.set(room.x, 1.5, room.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.name = room.name;
                mesh.userData.originalColor = new THREE.Color(room.color);
                
                scene.add(mesh);
                roomMeshes[room.name] = mesh;
            });

            // Floor (hidden - model has its own floor)
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            floor.visible = false; // Hide the floor
            scene.add(floor);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Format mesh name for display (remove _mesh, underscores, etc.)
        function formatMeshName(name) {
            if (!name) return 'Unknown';
            // Remove common suffixes like _mesh, _1, :meshname
            let formatted = name
                .replace(/_mesh.*$/i, '')
                .replace(/:\w+$/i, '')
                .replace(/_\d+$/i, '')
                .replace(/_/g, ' ')
                .trim();
            // Capitalize first letter of each word
            return formatted.split(' ').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            ).join(' ');
        }
        
        // Get element type from mesh name
        function getElementType(name) {
            if (!name) return null;
            const nameLower = name.toLowerCase();
            if (nameLower.includes('door') && !nameLower.includes('garage')) return 'door';
            if (nameLower.includes('garage')) return 'garage';
            if (nameLower.includes('window') || nameLower.includes('glass')) return 'window';
            return null;
        }
        
        // Currently selected interactive element
        let selectedInteractiveElement = null;
        
        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Raycast - check all objects in scene (including pivot groups)
            raycaster.setFromCamera(mouse, camera);
            const allObjects = [];
            // Include meshes from homeModel
            if (homeModel) {
                homeModel.traverse((child) => {
                    if (child.isMesh) allObjects.push(child);
                });
            }
            // Also include meshes that were reparented to pivot groups
            scene.traverse((child) => {
                if (child.isMesh && !allObjects.includes(child)) {
                    allObjects.push(child);
                }
            });
            const intersects = raycaster.intersectObjects(allObjects);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                const elementType = getElementType(clickedObject.name);
                
                // If it's an interactive element (door, garage, window), show selection panel
                if (elementType) {
                    showSelectionPanel(clickedObject, elementType);
                } else {
                    // For non-interactive elements, just select for color customization
                    selectMesh(clickedObject);
                    hideSelectionPanel();
                }
                
                // Also send message to Flutter if it's a room
                const clickedRoom = roomMeshes[clickedObject.name];
                if (clickedRoom && window.FlutterBridge) {
                    const formattedName = formatMeshName(clickedObject.name);
                    window.FlutterBridge.postMessage('tap:' + formattedName + ':' + (elementType || 'room'));
                }
            } else {
                // Clicked on empty space - hide selection panel
                hideSelectionPanel();
            }
        }
        
        // Show selection panel for interactive elements
        function showSelectionPanel(mesh, elementType) {
            const panel = document.getElementById('selection-panel');
            const iconEl = document.getElementById('selection-icon');
            const nameEl = document.getElementById('selection-name');
            const actionsEl = document.getElementById('selection-actions');
            const statusEl = document.getElementById('selection-status');
            
            if (!panel) return;
            
            selectedInteractiveElement = mesh;
            
            // Set icon and name based on type
            const displayName = formatMeshName(mesh.name);
            nameEl.textContent = displayName;
            
            // Clear previous actions
            actionsEl.innerHTML = '';
            
            // Get current state
            let isOpen = false;
            let statusText = '';
            
            switch (elementType) {
                case 'door':
                    iconEl.textContent = 'üö™';
                    isOpen = doorOpen;
                    statusText = isOpen ? 'Status: Open' : 'Status: Closed';
                    
                    // Add open/close button
                    const doorBtn = document.createElement('button');
                    doorBtn.className = 'selection-btn ' + (isOpen ? 'danger' : 'primary');
                    doorBtn.innerHTML = '<span class="btn-icon">' + (isOpen ? 'üîí' : 'üîì') + '</span>' + (isOpen ? 'Close Door' : 'Open Door');
                    doorBtn.onclick = () => {
                        toggleDoor();
                        setTimeout(() => showSelectionPanel(mesh, elementType), 100);
                    };
                    actionsEl.appendChild(doorBtn);
                    break;
                    
                case 'garage':
                    iconEl.textContent = 'üöó';
                    isOpen = garageOpen;
                    statusText = isOpen ? 'Status: Open' : 'Status: Closed';
                    
                    // Add open/close button
                    const garageBtn = document.createElement('button');
                    garageBtn.className = 'selection-btn ' + (isOpen ? 'danger' : 'primary');
                    garageBtn.innerHTML = '<span class="btn-icon">' + (isOpen ? '‚¨áÔ∏è' : '‚¨ÜÔ∏è') + '</span>' + (isOpen ? 'Close Garage' : 'Open Garage');
                    garageBtn.onclick = () => {
                        toggleGarage();
                        setTimeout(() => showSelectionPanel(mesh, elementType), 100);
                    };
                    actionsEl.appendChild(garageBtn);
                    break;
                    
                case 'window':
                    iconEl.textContent = 'ü™ü';
                    isOpen = mesh.userData.isOpen || false;
                    statusText = isOpen ? 'Status: Open' : 'Status: Closed';
                    
                    // Add open/close button for this window
                    const windowBtn = document.createElement('button');
                    windowBtn.className = 'selection-btn ' + (isOpen ? 'danger' : 'primary');
                    windowBtn.innerHTML = '<span class="btn-icon">' + (isOpen ? 'üîí' : 'üîì') + '</span>' + (isOpen ? 'Close Window' : 'Open Window');
                    windowBtn.onclick = () => {
                        toggleWindow(mesh);
                        setTimeout(() => showSelectionPanel(mesh, elementType), 600);
                    };
                    actionsEl.appendChild(windowBtn);
                    
                    // Add toggle all windows button
                    const allWindowsBtn = document.createElement('button');
                    allWindowsBtn.className = 'selection-btn';
                    allWindowsBtn.innerHTML = '<span class="btn-icon">ü™ü</span>' + (windowsOpen ? 'Close All Windows' : 'Open All Windows');
                    allWindowsBtn.onclick = () => {
                        toggleAllWindows();
                        setTimeout(() => showSelectionPanel(mesh, elementType), 600);
                    };
                    actionsEl.appendChild(allWindowsBtn);
                    break;
            }
            
            // Update status
            statusEl.textContent = statusText;
            statusEl.className = 'selection-status ' + (isOpen ? 'open' : 'closed');
            
            // Show panel
            panel.classList.add('active');
            
            // Also select mesh for color customization
            selectMesh(mesh);
        }
        
        // Hide selection panel
        function hideSelectionPanel() {
            const panel = document.getElementById('selection-panel');
            if (panel) {
                panel.classList.remove('active');
            }
            selectedInteractiveElement = null;
        }

        // Theme Management Functions
        function applyTheme(themeName) {
            if (!themes[themeName]) {
                console.error('Theme not found:', themeName);
                return;
            }

            const theme = themes[themeName];
            currentTheme = themeName;

            // Update all room mesh colors - be very specific about matching
            Object.entries(roomMeshes).forEach(([section, mesh]) => {
                // Map section names to theme color keys with exact matching
                let colorKey = null;
                const nameLower = section.toLowerCase();
                
                if (nameLower.includes('yard')) colorKey = 'yard';
                else if (nameLower.includes('door')) colorKey = 'door';
                else if (nameLower.includes('roof')) colorKey = 'roof';
                else if (nameLower.includes('glass') || nameLower.includes('window')) colorKey = 'glass';
                else if (nameLower.includes('garage')) colorKey = 'garage';
                else colorKey = 'home';

                const newColor = theme.colors[colorKey];
                if (newColor && mesh && mesh.material) {
                    mesh.material.color.setHex(newColor);
                    mesh.userData.originalColor?.setHex(newColor);
                    mesh.material.emissive.setHex(theme.emissive);
                    mesh.material.emissiveIntensity = theme.emissiveIntensity;
                    console.log(`Applied ${themeName}: ${section} (${colorKey}) -> #${newColor.toString(16).padStart(6, '0')}`);
                }
            });

            // Update buttons
            updateThemeButtons();
            console.log('‚úì Theme applied:', themeName);
        }

        function applyLighting(lightingLevel) {
            if (!lightingPresets[lightingLevel]) {
                console.error('Lighting preset not found:', lightingLevel);
                return;
            }

            const preset = lightingPresets[lightingLevel];
            currentLighting = lightingLevel;

            if (ambientLight) ambientLight.intensity = preset.ambientIntensity;
            if (directionalLight) directionalLight.intensity = preset.directionalIntensity;
            if (pointLight1) pointLight1.intensity = preset.pointIntensity;
            if (pointLight2) pointLight2.intensity = preset.pointIntensity;

            updateLightingButtons();
            console.log('üí° Lighting applied:', lightingLevel);
        }

        function toggleShadows() {
            shadowsEnabled = !shadowsEnabled;
            renderer.shadowMap.enabled = shadowsEnabled;
            
            // Update all meshes to cast/receive shadows
            scene.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = shadowsEnabled;
                    child.receiveShadow = shadowsEnabled;
                }
            });
            
            // Force shadow map update
            if (directionalLight && directionalLight.shadow) {
                directionalLight.shadow.needsUpdate = true;
            }
            renderer.shadowMap.needsUpdate = true;
            
            const btn = document.getElementById('toggle-shadows');
            if (btn) {
                btn.textContent = 'üåë Shadows: ' + (shadowsEnabled ? 'ON' : 'OFF');
                btn.classList.toggle('active', shadowsEnabled);
            }

            console.log('üåë Shadows:', shadowsEnabled ? 'enabled' : 'disabled');
        }
        
        function toggleGrid() {
            gridVisible = !gridVisible;
            if (gridHelper) {
                gridHelper.visible = gridVisible;
            }
            
            const btn = document.getElementById('toggle-grid');
            if (btn) {
                btn.textContent = 'üìê Grid: ' + (gridVisible ? 'ON' : 'OFF');
                btn.classList.toggle('active', gridVisible);
            }
            
            console.log('üìê Grid:', gridVisible ? 'visible' : 'hidden');
        }

        function updateThemeButtons() {
            document.querySelectorAll('[data-theme]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.theme === currentTheme);
            });
        }

        function updateLightingButtons() {
            document.querySelectorAll('[data-lighting]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lighting === currentLighting);
            });
        }

        // Mesh color functions (simplified)

        function initializeThemeUI() {
            console.log('Initializing Theme UI...');
            
            // Set up minimize/expand for theme panel by clicking emoji
            const panel = document.getElementById('theme-panel');
            const panelHeader = panel.querySelector('.panel-header');
            const miniBtn = document.getElementById('panel-mini-btn');
            
            if (panelHeader && panel) {
                panelHeader.addEventListener('click', () => {
                    panel.classList.toggle('minimized');
                });
            }
            
            if (miniBtn && panel) {
                miniBtn.addEventListener('click', () => {
                    panel.classList.remove('minimized');
                });
            }
            
            // Set up mesh color picker inputs
            const colorInput = document.getElementById('selected-mesh-color-input');
            const hexInput = document.getElementById('selected-mesh-hex-input');
            
            if (colorInput) {
                colorInput.addEventListener('change', (e) => {
                    const hexValue = e.target.value;
                    if (hexInput) hexInput.value = hexValue;
                    updateSelectedMeshColor(hexValue);
                });
                colorInput.addEventListener('input', (e) => {
                    updateSelectedMeshColor(e.target.value);
                });
            }
            
            if (hexInput) {
                hexInput.addEventListener('change', (e) => {
                    let hexValue = e.target.value.trim();
                    if (!hexValue.startsWith('#')) hexValue = '#' + hexValue;
                    if (!/^#[0-9A-Fa-f]{6}$/.test(hexValue)) {
                        console.warn('Invalid hex color:', hexValue);
                        return;
                    }
                    if (colorInput) colorInput.value = hexValue;
                    updateSelectedMeshColor(hexValue);
                });
            }
            
            // Set up theme button listeners
            document.querySelectorAll('[data-theme]').forEach(btn => {
                btn.addEventListener('click', () => {
                    applyTheme(btn.dataset.theme);
                });
            });

            // Set up lighting button listeners
            document.querySelectorAll('[data-lighting]').forEach(btn => {
                btn.addEventListener('click', () => {
                    applyLighting(btn.dataset.lighting);
                });
            });

            // Set up shadows toggle listener
            const shadowToggle = document.getElementById('toggle-shadows');
            if (shadowToggle) {
                shadowToggle.addEventListener('click', toggleShadows);
            }
            
            // Set up grid toggle listener
            const gridToggle = document.getElementById('toggle-grid');
            if (gridToggle) {
                gridToggle.addEventListener('click', toggleGrid);
            }

            updateThemeButtons();
            updateLightingButtons();
            initializeNavbar();
            initializeSelectionPanel();
            initializeMobileDrawer();
            initFloatingPaintPicker();
            console.log('All UI initialized successfully');
        }
        
        // Toast notification function for feedback
        function showToast(message, duration = 2500) {
            const container = document.getElementById('toast-container');
            if (!container) return;
            
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            container.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => toast.classList.add('show'), 10);
            
            // Remove after duration
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }
        
        // Initialize Mobile Drawer
        function initializeMobileDrawer() {
            const menuBtn = document.getElementById('mobile-menu-btn');
            const drawer = document.getElementById('mobile-drawer');
            const overlay = document.getElementById('drawer-overlay');
            const closeBtn = document.getElementById('drawer-close');
            
            function openDrawer() {
                if (drawer) drawer.classList.add('active');
                if (overlay) overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
            
            function closeDrawer() {
                if (drawer) drawer.classList.remove('active');
                if (overlay) overlay.classList.remove('active');
                document.body.style.overflow = '';
            }
            
            if (menuBtn) {
                menuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openDrawer();
                });
            }
            
            if (closeBtn) {
                closeBtn.addEventListener('click', closeDrawer);
            }
            
            if (overlay) {
                overlay.addEventListener('click', closeDrawer);
            }
            
            // ====== THEME BUTTONS ======
            drawer.querySelectorAll('[data-theme]').forEach(btn => {
                btn.addEventListener('click', () => {
                    applyTheme(btn.dataset.theme);
                    // Update active states
                    drawer.querySelectorAll('[data-theme]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    showToast('üé≠ Theme: ' + btn.dataset.theme);
                });
            });
            
            // ====== LIGHTING BUTTONS ======
            drawer.querySelectorAll('[data-lighting]').forEach(btn => {
                btn.addEventListener('click', () => {
                    applyLighting(btn.dataset.lighting);
                    // Update active states
                    drawer.querySelectorAll('[data-lighting]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    showToast('üí° Lighting: ' + btn.dataset.lighting);
                });
            });
            
            // ====== SHADOWS TOGGLE ======
            const shadowsBtn = document.getElementById('drawer-toggle-shadows');
            if (shadowsBtn) {
                shadowsBtn.addEventListener('click', () => {
                    toggleShadows();
                    shadowsBtn.textContent = renderer.shadowMap.enabled ? '‚òÄÔ∏è Shadows: ON' : 'üåë Shadows: OFF';
                });
            }
            
            // ====== TIME SLIDER ======
            const timeSlider = document.getElementById('drawer-time-slider');
            const timeDisplay = document.getElementById('drawer-time-display');
            const autoTimeBtn = document.getElementById('drawer-auto-time');
            
            if (timeSlider) {
                timeSlider.addEventListener('input', () => {
                    const hour = parseFloat(timeSlider.value);
                    const displayHour = Math.floor(hour);
                    const displayMin = Math.floor((hour % 1) * 60);
                    const timeStr = `${displayHour.toString().padStart(2, '0')}:${displayMin.toString().padStart(2, '0')}`;
                    if (timeDisplay) timeDisplay.textContent = timeStr;
                    setTimeOfDay(hour);
                    if (autoTimeBtn) {
                        autoTimeBtn.classList.remove('active');
                        autoTimeBtn.textContent = 'üïê Auto Time: OFF';
                    }
                });
            }
            
            if (autoTimeBtn) {
                autoTimeBtn.addEventListener('click', () => {
                    isAutoTimeEnabled = !isAutoTimeEnabled;
                    autoTimeBtn.classList.toggle('active', isAutoTimeEnabled);
                    autoTimeBtn.textContent = isAutoTimeEnabled ? 'üïê Auto Time: ON' : 'üïê Auto Time: OFF';
                    if (isAutoTimeEnabled) {
                        updateDayNightCycle();
                        showToast('üåÖ Auto time enabled');
                    } else {
                        showToast('üåÖ Manual time mode');
                    }
                });
            }
            
            // ====== PAINT MODE ======
            const enablePaintBtn = document.getElementById('drawer-enable-paint-mode');
            const paintInfo = document.getElementById('drawer-paint-info');
            const colorPicker = document.getElementById('drawer-color-picker');
            const hexInput = document.getElementById('drawer-hex-input');
            const applyColorBtn = document.getElementById('drawer-apply-color');
            const floatingPicker = document.getElementById('floating-paint-picker');
            
            function updatePaintModeButton() {
                if (enablePaintBtn) {
                    if (isPaintModeActive) {
                        enablePaintBtn.textContent = 'üö´ Disable Paint Mode';
                        enablePaintBtn.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
                    } else {
                        enablePaintBtn.textContent = 'üé® Enable Paint Mode';
                        enablePaintBtn.style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
                    }
                }
            }
            
            if (enablePaintBtn) {
                enablePaintBtn.addEventListener('click', () => {
                    isPaintModeActive = !isPaintModeActive;
                    currentTool = isPaintModeActive ? 'paint' : 'select';
                    updatePaintModeButton();
                    
                    if (isPaintModeActive) {
                        closeDrawer();
                        showToast('üé® Paint Mode ON: Tap any object');
                    } else {
                        // Hide floating picker when paint mode is disabled
                        if (floatingPicker) floatingPicker.classList.remove('visible');
                        showToast('‚úã Paint Mode OFF');
                    }
                });
            }
            
            if (applyColorBtn && colorPicker) {
                applyColorBtn.addEventListener('click', () => {
                    if (selectedMesh) {
                        updateSelectedMeshColor(colorPicker.value);
                        showToast('üé® Color applied!');
                    }
                });
            }
            
            if (colorPicker) {
                colorPicker.addEventListener('input', (e) => {
                    if (hexInput) hexInput.value = e.target.value;
                    if (selectedMesh) {
                        updateSelectedMeshColor(e.target.value);
                    }
                });
            }
            
            if (hexInput) {
                hexInput.addEventListener('change', (e) => {
                    let hex = e.target.value.trim();
                    if (!hex.startsWith('#')) hex = '#' + hex;
                    if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                        if (colorPicker) colorPicker.value = hex;
                        if (selectedMesh) {
                            updateSelectedMeshColor(hex);
                        }
                    }
                });
            }
            
            // ====== RESET COLORS ======
            const resetColorsBtn = document.getElementById('drawer-reset-colors');
            if (resetColorsBtn) {
                resetColorsBtn.addEventListener('click', () => {
                    resetAllColors();
                    showToast('‚Ü∫ All colors reset');
                });
            }
            
            // ====== HOME CONTROLS ======
            const lightsBtn = document.getElementById('drawer-toggle-lights');
            if (lightsBtn) {
                lightsBtn.addEventListener('click', () => {
                    toggleLights();
                    showToast('üí° Lights toggled');
                });
            }
            
            const doorBtn = document.getElementById('drawer-toggle-door');
            if (doorBtn) {
                doorBtn.addEventListener('click', () => {
                    if (!doorMesh) findDoor();
                    if (doorMesh) {
                        toggleDoor();
                        showToast(doorOpen ? 'üö™ Door opened' : 'üö™ Door closed');
                    } else {
                        showToast('üö™ No door in model');
                    }
                });
            }
            
            const garageBtn = document.getElementById('drawer-toggle-garage');
            if (garageBtn) {
                garageBtn.addEventListener('click', () => {
                    if (!garageMesh) findGarage();
                    if (garageMesh) {
                        toggleGarage();
                        showToast(garageOpen ? 'üöó Garage opened' : 'üöó Garage closed');
                    } else {
                        showToast('üöó No garage in model');
                    }
                });
            }
            
            const windowsBtn = document.getElementById('drawer-toggle-windows');
            if (windowsBtn) {
                windowsBtn.addEventListener('click', () => {
                    if (windowMeshes.length === 0) findWindows();
                    if (windowMeshes.length > 0) {
                        toggleAllWindows();
                        showToast('ü™ü Windows toggled');
                    } else {
                        showToast('ü™ü No windows in model');
                    }
                });
            }
            
            // ====== VIEW CONTROLS ======
            const resetCameraBtn = document.getElementById('drawer-reset-camera');
            if (resetCameraBtn) {
                resetCameraBtn.addEventListener('click', () => {
                    resetCamera();
                    showToast('üéØ View reset');
                });
            }
            
            const gridBtn = document.getElementById('drawer-toggle-grid');
            if (gridBtn) {
                gridBtn.addEventListener('click', () => {
                    toggleGrid();
                    showToast('üìê Grid toggled');
                });
            }
            
            // Enable drawer scrolling by handling touch events
            const drawerContent = document.querySelector('.drawer-content');
            if (drawerContent) {
                drawerContent.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                }, { passive: true });
                
                drawerContent.addEventListener('touchmove', (e) => {
                    e.stopPropagation();
                }, { passive: true });
                
                drawerContent.addEventListener('wheel', (e) => {
                    e.stopPropagation();
                }, { passive: true });
            }
            
            console.log('Mobile drawer initialized with full controls');
        }
        
        function initializeSelectionPanel() {
            const closeBtn = document.getElementById('selection-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    hideSelectionPanel();
                });
            }
            
            // Close panel when clicking outside
            document.addEventListener('click', (e) => {
                const panel = document.getElementById('selection-panel');
                if (panel && panel.classList.contains('active')) {
                    if (!e.target.closest('#selection-panel') && !e.target.closest('#canvas-container')) {
                        hideSelectionPanel();
                    }
                }
            });
        }
        
        let selectedMesh = null;
        let currentTool = 'paint';
        let hudTemperature = 22;
        let activeDropdown = null;
        let isPaintModeActive = false;
        
        // Update drawer paint info when mesh is selected
        function updateDrawerPaintInfo(mesh) {
            const paintInfo = document.getElementById('drawer-paint-info');
            const meshNameEl = document.getElementById('drawer-mesh-name');
            const colorPicker = document.getElementById('drawer-color-picker');
            
            // Also update floating paint picker
            const floatingPicker = document.getElementById('floating-paint-picker');
            const floatingMeshName = document.getElementById('floating-mesh-name');
            const floatingColorPicker = document.getElementById('floating-color-picker');
            const floatingHexInput = document.getElementById('floating-hex-input');
            
            if (mesh && paintInfo && meshNameEl) {
                paintInfo.style.display = 'block';
                meshNameEl.textContent = formatMeshName(mesh.name || 'Object');
                
                // Get current color of mesh
                if (mesh.material && mesh.material.color && colorPicker) {
                    const hexColor = '#' + mesh.material.color.getHexString();
                    colorPicker.value = hexColor;
                    const hexInput = document.getElementById('drawer-hex-input');
                    if (hexInput) hexInput.value = hexColor;
                }
            }
            
            // Update and show floating paint picker when paint mode is active
            if (mesh && isPaintModeActive) {
                const hexColor = mesh.material?.color ? '#' + mesh.material.color.getHexString() : '#ff0000';
                
                if (floatingMeshName) floatingMeshName.textContent = 'üè† ' + formatMeshName(mesh.name || 'Object');
                if (floatingColorPicker) floatingColorPicker.value = hexColor;
                if (floatingHexInput) floatingHexInput.value = hexColor;
                if (floatingPicker) floatingPicker.classList.add('visible');
            }
        }
        
        // Initialize floating paint picker
        function initFloatingPaintPicker() {
            const floatingPicker = document.getElementById('floating-paint-picker');
            const floatingClose = document.getElementById('floating-paint-close');
            const floatingColorPicker = document.getElementById('floating-color-picker');
            const floatingHexInput = document.getElementById('floating-hex-input');
            const floatingApply = document.getElementById('floating-paint-apply');
            
            if (!floatingPicker) return;
            
            // Prevent touch events from closing picker
            floatingPicker.addEventListener('touchstart', e => e.stopPropagation(), { passive: false });
            floatingPicker.addEventListener('touchmove', e => e.stopPropagation(), { passive: false });
            floatingPicker.addEventListener('click', e => e.stopPropagation());
            
            // Close button (just hides picker, keeps paint mode)
            if (floatingClose) {
                floatingClose.addEventListener('click', () => {
                    floatingPicker.classList.remove('visible');
                });
            }
            
            // Exit paint mode button
            const floatingExit = document.getElementById('floating-paint-exit');
            if (floatingExit) {
                floatingExit.addEventListener('click', () => {
                    isPaintModeActive = false;
                    currentTool = 'select';
                    floatingPicker.classList.remove('visible');
                    
                    // Update drawer button if visible
                    const enablePaintBtn = document.getElementById('drawer-enable-paint-mode');
                    if (enablePaintBtn) {
                        enablePaintBtn.textContent = 'üé® Enable Paint Mode';
                        enablePaintBtn.style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
                    }
                    
                    showToast('‚úã Paint Mode OFF');
                });
            }
            
            // Sync color picker with hex input
            if (floatingColorPicker && floatingHexInput) {
                floatingColorPicker.addEventListener('input', () => {
                    floatingHexInput.value = floatingColorPicker.value;
                });
                
                floatingHexInput.addEventListener('input', () => {
                    const value = floatingHexInput.value;
                    if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
                        floatingColorPicker.value = value;
                    }
                });
            }
            
            // Apply button
            if (floatingApply) {
                floatingApply.addEventListener('click', () => {
                    if (!selectedMesh) {
                        showToast('‚ö†Ô∏è No object selected');
                        return;
                    }
                    
                    const hexColor = floatingColorPicker?.value || '#ff0000';
                    updateSelectedMeshColor(hexColor);
                    showToast('‚úÖ Applied ' + hexColor + ' to ' + formatMeshName(selectedMesh.name));
                });
            }
            
            console.log('‚úì Floating paint picker initialized');
        }
        
        function initializeNavbar() {
            console.log('Initializing unified navbar...');
            
            // Close all dropdowns
            function closeAllDropdowns() {
                document.querySelectorAll('.dropdown-panel').forEach(panel => {
                    panel.classList.remove('active');
                });
                activeDropdown = null;
            }
            
            // Toggle dropdown panel
            function toggleDropdown(panelId) {
                const panel = document.getElementById(panelId);
                if (!panel) return;
                
                if (activeDropdown === panelId) {
                    panel.classList.remove('active');
                    activeDropdown = null;
                } else {
                    closeAllDropdowns();
                    panel.classList.add('active');
                    activeDropdown = panelId;
                }
            }
            
            // Navbar button click handlers
            document.querySelectorAll('#main-navbar .nav-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const tool = btn.dataset.tool;
                    console.log('Navbar button clicked:', tool);
                    
                    // Handle different tools
                    switch(tool) {
                        case 'paint':
                            // Remove active from others, add to this
                            document.querySelectorAll('#main-navbar .nav-btn').forEach(b => {
                                if (b.dataset.tool !== 'settings' && b.dataset.tool !== 'theme' && b.dataset.tool !== 'daynight') {
                                    b.classList.remove('active');
                                }
                            });
                            btn.classList.add('active');
                            currentTool = 'paint';
                            toggleDropdown('color-picker-panel');
                            break;
                            
                        case 'theme':
                            toggleDropdown('theme-dropdown');
                            break;
                            
                        case 'daynight':
                            toggleDropdown('daynight-panel');
                            break;
                            
                        case 'settings':
                            toggleDropdown('settings-dropdown');
                            break;
                            
                        case 'light':
                            toggleLights();
                            btn.classList.toggle('active');
                            break;
                            
                        case 'doors':
                            // Find a door mesh and show selection panel
                            if (!doorMesh) findDoor();
                            if (doorMesh) {
                                showSelectionPanel(doorMesh, 'door');
                            } else {
                                console.log('No door found in model');
                            }
                            break;
                            
                        case 'garage':
                            // Find garage mesh and show selection panel
                            if (!garageMesh) findGarage();
                            if (garageMesh) {
                                showSelectionPanel(garageMesh, 'garage');
                            } else {
                                console.log('No garage found in model');
                            }
                            break;
                            
                        case 'windows':
                            // Find windows and show selection panel for the first one
                            if (windowMeshes.length === 0) findWindows();
                            if (windowMeshes.length > 0) {
                                showSelectionPanel(windowMeshes[0], 'window');
                            } else {
                                console.log('No windows found in model');
                            }
                            break;
                            
                        case 'reset':
                            resetAllColors();
                            break;
                    }
                });
            });
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.dropdown-panel') && !e.target.closest('.nav-btn')) {
                    closeAllDropdowns();
                }
            });
            
            // Theme buttons in dropdown
            document.querySelectorAll('#theme-dropdown .dropdown-btn[data-theme]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#theme-dropdown .dropdown-btn[data-theme]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    setTheme(btn.dataset.theme);
                });
            });
            
            // Lighting buttons in dropdown
            document.querySelectorAll('#theme-dropdown .dropdown-btn[data-lighting]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#theme-dropdown .dropdown-btn[data-lighting]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    setLighting(btn.dataset.lighting);
                });
            });
            
            // Time slider
            const timeSlider = document.getElementById('time-slider');
            const timeDisplay = document.getElementById('time-display');
            const autoTimeBtn = document.getElementById('auto-time-toggle');
            
            if (timeSlider) {
                timeSlider.addEventListener('input', () => {
                    const hour = parseFloat(timeSlider.value);
                    const displayHour = Math.floor(hour);
                    const displayMin = Math.floor((hour % 1) * 60);
                    const timeStr = `${displayHour.toString().padStart(2, '0')}:${displayMin.toString().padStart(2, '0')}`;
                    timeDisplay.textContent = timeStr;
                    // Sync drawer time
                    const drawerTime = document.getElementById('drawer-time');
                    if (drawerTime) drawerTime.textContent = timeStr;
                    setTimeOfDay(hour);
                    if (autoTimeBtn) {
                        autoTimeBtn.classList.remove('active');
                        autoTimeBtn.textContent = 'üïê Auto Time: OFF';
                    }
                });
            }
            
            if (autoTimeBtn) {
                autoTimeBtn.addEventListener('click', () => {
                    isAutoTimeEnabled = !isAutoTimeEnabled;
                    autoTimeBtn.classList.toggle('active', isAutoTimeEnabled);
                    autoTimeBtn.textContent = isAutoTimeEnabled ? 'üïê Auto Time: ON' : 'üïê Auto Time: OFF';
                    if (isAutoTimeEnabled) {
                        updateDayNightCycle();
                    }
                });
            }
            
            // Settings dropdown buttons
            const resetCameraBtn = document.getElementById('reset-camera');
            if (resetCameraBtn) {
                resetCameraBtn.addEventListener('click', () => {
                    resetCamera();
                    console.log('Camera reset');
                });
            }
            
            // Fetch real temperature from weather API (Alexandria, Egypt)
            fetchWeatherTemperature();
            // Refresh every 10 minutes
            setInterval(fetchWeatherTemperature, 600000);
            
            // Initial temperature display
            updateTemperatureDisplay(hudTemperature);
        }
        
        // Fetch weather from Open-Meteo API (free, no API key needed)
        async function fetchWeatherTemperature() {
            try {
                // Alexandria, Egypt coordinates: 31.2001, 29.9187
                const response = await fetch(
                    'https://api.open-meteo.com/v1/forecast?latitude=31.2001&longitude=29.9187&current_weather=true'
                );
                if (response.ok) {
                    const data = await response.json();
                    if (data.current_weather && data.current_weather.temperature !== undefined) {
                        hudTemperature = data.current_weather.temperature;
                        updateTemperatureDisplay(hudTemperature);
                        console.log('üå°Ô∏è Weather updated:', hudTemperature + '¬∞C from Alexandria, Egypt');
                    }
                } else {
                    console.log('‚ö†Ô∏è Weather API not available, using fallback');
                    useFallbackTemperature();
                }
            } catch (error) {
                console.log('‚ö†Ô∏è Could not fetch weather (offline?), using fallback:', error.message);
                useFallbackTemperature();
            }
        }
        
        // Fallback temperature when API unavailable
        function useFallbackTemperature() {
            // Estimate temperature based on time of day (typical for Alexandria)
            const now = new Date();
            const hour = now.getHours();
            // Alexandria typical temps: night 18-22¬∞C, day 25-32¬∞C
            if (hour >= 6 && hour < 12) {
                hudTemperature = 22 + Math.random() * 4; // Morning: 22-26
            } else if (hour >= 12 && hour < 18) {
                hudTemperature = 26 + Math.random() * 6; // Afternoon: 26-32
            } else if (hour >= 18 && hour < 22) {
                hudTemperature = 22 + Math.random() * 4; // Evening: 22-26
            } else {
                hudTemperature = 18 + Math.random() * 4; // Night: 18-22
            }
            hudTemperature = Math.round(hudTemperature * 10) / 10;
            updateTemperatureDisplay(hudTemperature);
        }
        
        // Get temperature color based on value
        function getTemperatureColor(temp) {
            if (temp < 0) return '#0000FF';        // Pure blue (freezing)
            if (temp < 10) return '#0066FF';       // Blue (cold)
            if (temp < 15) return '#00AAFF';       // Cyan-blue (cool)
            if (temp < 18) return '#00DDFF';       // Cyan (slightly cool)
            if (temp < 22) return '#00FFAA';       // Cyan-green (comfortable cool)
            if (temp < 25) return '#66FF66';       // Green (ideal)
            if (temp < 28) return '#AAFF00';       // Yellow-green (warm)
            if (temp < 32) return '#FFDD00';       // Yellow (hot)
            if (temp < 36) return '#FFAA00';       // Orange (very hot)
            if (temp < 40) return '#FF6600';       // Orange-red (extreme)
            return '#FF0000';                       // Red (dangerous)
        }
        
        // Update temperature display with color (value + unit)
        function updateTemperatureDisplay(temp) {
            const tempEl = document.getElementById('temp-value');
            const unitEl = document.getElementById('temp-unit');
            const color = getTemperatureColor(temp);
            
            if (tempEl) {
                tempEl.textContent = temp.toFixed(1);
                tempEl.style.color = color;
            }
            if (unitEl) {
                unitEl.style.color = color;
            }
            // Sync drawer temperature
            const drawerTemp = document.getElementById('drawer-temp');
            if (drawerTemp) {
                drawerTemp.textContent = temp.toFixed(0) + '¬∞C';
                drawerTemp.style.color = color;
            }
        }
        
        // Get time color based on hour
        function getTimeColor(hour) {
            if (hour >= 21 || hour < 5) return '#AAAACC';      // Night - pale blue/white
            if (hour < 7) return '#FFB366';                     // Dawn - soft orange
            if (hour < 9) return '#FFDD66';                     // Morning - golden yellow
            if (hour < 17) return '#FFFFFF';                    // Day - white
            if (hour < 19) return '#FFB366';                    // Evening - warm orange
            return '#CC99FF';                                   // Dusk - purple
        }
        
        // Stars for night sky
        let starsGroup = null;
        
        function createStars() {
            if (starsGroup) return starsGroup;
            
            starsGroup = new THREE.Group();
            
            // Simple white dot stars
            const starGeometry = new THREE.SphereGeometry(0.8, 4, 4);
            const starMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            
            // Create 300 white dot stars
            for (let i = 0; i < 300; i++) {
                const star = new THREE.Mesh(starGeometry, starMaterial.clone());
                
                // Random position on sky dome
                const radius = 250 + Math.random() * 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 0.5;
                
                star.position.x = radius * Math.sin(phi) * Math.cos(theta);
                star.position.y = radius * Math.cos(phi) + 30;
                star.position.z = radius * Math.sin(phi) * Math.sin(theta);
                
                // Slight random brightness
                star.material.opacity = 0.7 + Math.random() * 0.3;
                star.material.transparent = true;
                
                starsGroup.add(star);
            }
            
            scene.add(starsGroup);
            console.log('‚≠ê Created', starsGroup.children.length, 'white stars');
            // Initially visible based on current time
            const now = new Date();
            const currentHour = now.getHours();
            starsGroup.visible = (currentHour >= 21 || currentHour < 5);
            console.log('‚≠ê Stars created, visible:', starsGroup.visible, 'hour:', currentHour);
            return starsGroup;
        }
        
        function updateStarsVisibility(hour) {
            if (!starsGroup) createStars();
            
            // Stars visible between 18:00 and 6:00 (dusk to dawn)
            const isNightTime = hour >= 18 || hour < 6;
            starsGroup.visible = isNightTime;
            console.log('‚≠ê Stars visibility:', isNightTime, 'at hour:', hour);
            
            // Twinkle effect
            if (isNightTime) {
                starsGroup.children.forEach(star => {
                    star.material.opacity = 0.3 + Math.random() * 0.7;
                });
            }
        }
        
        function resetAllColors() {
            Object.entries(roomMeshes).forEach(([name, mesh]) => {
                if (mesh.userData.originalColor && mesh.material) {
                    mesh.material.color.copy(mesh.userData.originalColor);
                }
            });
            console.log('All colors reset to defaults');
        }
        
        function selectMesh(mesh) {
            // Deselect previous mesh
            if (selectedMesh) {
                selectedMesh.userData.isSelected = false;
            }
            
            selectedMesh = mesh;
            mesh.userData.isSelected = true;
            
            // Update desktop color picker panel
            const meshNameDisplay = document.getElementById('selected-mesh-name');
            const colorInput = document.getElementById('selected-mesh-color-input');
            const hexInput = document.getElementById('selected-mesh-hex-input');
            const colorPanel = document.getElementById('selected-mesh-color-panel');
            
            if (meshNameDisplay) {
                // Use formatted name for display
                meshNameDisplay.textContent = 'Object: ' + formatMeshName(mesh.name);
            }
            
            if (colorInput && hexInput && mesh.material && mesh.material.color) {
                const hexColor = '#' + mesh.material.color.getHexString();
                colorInput.value = hexColor;
                hexInput.value = hexColor;
            }
            
            if (colorPanel) {
                colorPanel.classList.add('active');
            }
            
            // Update drawer paint info (for mobile)
            updateDrawerPaintInfo(mesh);
            
            // Show toast feedback in paint mode
            if (isPaintModeActive) {
                showToast('üé® Selected: ' + formatMeshName(mesh.name));
            }
            
            console.log('‚ïê‚ïê‚ïê MESH SELECTED ‚ïê‚ïê‚ïê');
            console.log('Name:', mesh.name);
            console.log('Current Color:', '#' + (mesh.material?.color?.getHexString() || 'unknown'));
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        }
        
        function updateSelectedMeshColor(hexColor) {
            if (!selectedMesh) {
                console.warn('‚ö†Ô∏è No mesh selected');
                return;
            }
            
            if (!selectedMesh.material || !selectedMesh.material.color) {
                console.error('‚ùå Selected mesh has no material or color');
                return;
            }
            
            const colorValue = parseInt(hexColor.replace('#', ''), 16);
            selectedMesh.material.color.setHex(colorValue);
            meshColorOverrides[selectedMesh.name] = hexColor;
            
            console.log('‚úì Updated', selectedMesh.name, 'to', hexColor, '- New Material ID:', selectedMesh.material.uuid);
        }

        // Track time for day/night updates
        let lastDayNightUpdate = 0;
        const dayNightUpdateInterval = 60000; // Update every 60 seconds

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // Update day/night cycle periodically
            const now = Date.now();
            if (isAutoTimeEnabled && now - lastDayNightUpdate > dayNightUpdateInterval) {
                updateDayNightCycle();
                lastDayNightUpdate = now;
            }
            
            renderer.render(scene, camera);
        }

        // Function to update alarms from Flutter
        function updateAlarms(alarmsJson) {
            try {
                // Handle both string and object inputs
                let alarmsData;
                if (typeof alarmsJson === 'string') {
                    alarmsData = JSON.parse(alarmsJson);
                } else {
                    alarmsData = alarmsJson;
                }
                const alarms = alarmsData.alarms || alarmsData;

                // Clear previous alarm visualizations
                Object.values(alarmMeshes).forEach(mesh => {
                    scene.remove(mesh);
                });
                alarmMeshes = {};

                // Reset all room colors
                Object.values(roomMeshes).forEach(mesh => {
                    mesh.material.color.copy(mesh.userData.originalColor);
                    mesh.material.emissive.setHex(0x000000);
                });

                // Apply alarm visualizations
                Object.entries(alarms).forEach(([section, alarm]) => {
                    const roomMesh = roomMeshes[section];
                    if (roomMesh) {
                        // Change room color based on alarm severity
                        const color = new THREE.Color(alarm.color);
                        roomMesh.material.color.copy(color);
                        roomMesh.material.emissive.copy(color);
                        roomMesh.material.emissiveIntensity = 0.3;

                        // Add pulsing effect
                        let intensity = 0.3;
                        let increasing = true;
                        const pulseInterval = setInterval(() => {
                            if (increasing) {
                                intensity += 0.05;
                                if (intensity >= 0.6) increasing = false;
                            } else {
                                intensity -= 0.05;
                                if (intensity <= 0.3) increasing = true;
                            }
                            if (roomMesh.material) {
                                roomMesh.material.emissiveIntensity = intensity;
                            }
                        }, 100);

                        // Store interval for cleanup
                        roomMesh.userData.pulseInterval = pulseInterval;
                    }
                });
            } catch (error) {
                console.error('Error updating alarms:', error);
            }
        }

        // Function to reset camera view
        function resetCamera() {
            camera.position.set(18, 12, 22);
            controls.target.set(0, 2, 0);
            controls.update();
        }

        // Door animation functions
        let doorMesh = null;
        let doorAnimating = false;
        let doorOpen = false;

        // Garage animation variables
        let garageMesh = null;
        let garageAnimating = false;
        let garageOpen = false;

        // Window animation variables
        let windowMeshes = [];
        let windowAnimating = false;
        let windowsOpen = false;

        // Animation state tracking for all interactive elements
        const animationStates = {
            doors: {},
            garages: {},
            windows: {}
        };

        function findDoor() {
            // First try exact names
            const doorNames = ['door', 'Door', 'DOOR', 'entrance_door', 'front_door', 'main_door', 'porte', 'Porte'];
            for (const name of doorNames) {
                if (roomMeshes[name]) {
                    doorMesh = roomMeshes[name];
                    if (!doorMesh.userData.originalRotation) {
                        doorMesh.userData.originalRotation = doorMesh.rotation.clone();
                    }
                    console.log('üö™ Found door mesh (exact):', name);
                    return true;
                }
            }
            
            // Then try partial matches (but exclude garage doors)
            for (const [name, mesh] of Object.entries(roomMeshes)) {
                const nameLower = name.toLowerCase();
                if (nameLower.includes('door') && !nameLower.includes('garage')) {
                    doorMesh = mesh;
                    if (!doorMesh.userData.originalRotation) {
                        doorMesh.userData.originalRotation = doorMesh.rotation.clone();
                    }
                    console.log('üö™ Found door mesh (partial):', name);
                    return true;
                }
            }
            
            console.log('‚ö†Ô∏è Door mesh not found. Available meshes:', Object.keys(roomMeshes));
            return false;
        }

        function findGarage() {
            // First try exact names
            const garageNames = ['garage', 'Garage', 'GARAGE', 'garage_door', 'garagedoor'];
            for (const name of garageNames) {
                if (roomMeshes[name]) {
                    garageMesh = roomMeshes[name];
                    if (!garageMesh.userData.originalPosition) {
                        garageMesh.userData.originalPosition = garageMesh.position.clone();
                    }
                    console.log('üöó Found garage mesh (exact):', name);
                    return true;
                }
            }
            
            // Then try partial matches
            for (const [name, mesh] of Object.entries(roomMeshes)) {
                if (name.toLowerCase().includes('garage')) {
                    garageMesh = mesh;
                    if (!garageMesh.userData.originalPosition) {
                        garageMesh.userData.originalPosition = garageMesh.position.clone();
                    }
                    console.log('üöó Found garage mesh (partial):', name);
                    return true;
                }
            }
            
            console.log('‚ö†Ô∏è Garage mesh not found');
            return false;
        }

        function findWindows() {
            windowMeshes = [];
            const windowPatterns = ['window', 'Window', 'WINDOW', 'glass', 'Glass'];
            Object.entries(roomMeshes).forEach(([name, mesh]) => {
                for (const pattern of windowPatterns) {
                    if (name.toLowerCase().includes(pattern.toLowerCase())) {
                        if (!mesh.userData.originalPosition) {
                            mesh.userData.originalPosition = mesh.position.clone();
                        }
                        if (!mesh.userData.originalRotation) {
                            mesh.userData.originalRotation = mesh.rotation.clone();
                        }
                        windowMeshes.push(mesh);
                        console.log('ü™ü Found window mesh:', name);
                        break;
                    }
                }
            });
            return windowMeshes.length > 0;
        }

        // Toggle any interactive element when clicked
        function toggleInteractiveElement(mesh) {
            if (!mesh || !mesh.name) return false;
            
            const nameLower = mesh.name.toLowerCase();
            
            // Check if it's a door
            if (nameLower.includes('door') && !nameLower.includes('garage')) {
                toggleDoor();
                return true;
            }
            
            // Check if it's a garage
            if (nameLower.includes('garage')) {
                toggleGarage();
                return true;
            }
            
            // Check if it's a window
            if (nameLower.includes('window') || nameLower.includes('glass')) {
                toggleWindow(mesh);
                return true;
            }
            
            return false;
        }

        // Toggle door open/close
        function toggleDoor() {
            if (!doorMesh) {
                if (!findDoor()) {
                    // Try harder to find door
                    Object.entries(roomMeshes).forEach(([name, mesh]) => {
                        if (name.toLowerCase().includes('door') && !name.toLowerCase().includes('garage')) {
                            doorMesh = mesh;
                            if (!doorMesh.userData.originalRotation) {
                                doorMesh.userData.originalRotation = doorMesh.rotation.clone();
                            }
                            console.log('üö™ Found door mesh:', name);
                        }
                    });
                }
            }
            if (doorOpen) {
                closeDoor();
            } else {
                openDoor();
            }
        }

        // Toggle garage open/close
        function toggleGarage() {
            if (!garageMesh) {
                if (!findGarage()) {
                    // Try harder to find garage
                    Object.entries(roomMeshes).forEach(([name, mesh]) => {
                        if (name.toLowerCase().includes('garage')) {
                            garageMesh = mesh;
                            if (!garageMesh.userData.originalPosition) {
                                garageMesh.userData.originalPosition = garageMesh.position.clone();
                            }
                            if (!garageMesh.userData.originalRotation) {
                                garageMesh.userData.originalRotation = garageMesh.rotation.clone();
                            }
                            console.log('üöó Found garage mesh:', name);
                        }
                    });
                }
            }
            if (garageOpen) {
                closeGarage();
            } else {
                openGarage();
            }
        }

        // Toggle individual window
        function toggleWindow(windowMesh) {
            if (!windowMesh) return;
            const isOpen = windowMesh.userData.isOpen || false;
            if (isOpen) {
                closeWindowMesh(windowMesh);
            } else {
                openWindowMesh(windowMesh);
            }
        }

        function openGarage() {
            if (!garageMesh) {
                if (!findGarage()) {
                    console.log('‚ùå Cannot animate garage - mesh not found');
                    // List available meshes for debugging
                    console.log('Available meshes:', Object.keys(roomMeshes).join(', '));
                    return;
                }
            }

            if (garageAnimating || garageOpen) {
                console.log('‚ö†Ô∏è Garage already open or animating');
                return;
            }

            console.log('üöó Opening garage (tilting up)...');
            garageAnimating = true;

            // Ensure originalRotation is set
            if (!garageMesh.userData.originalRotation) {
                garageMesh.userData.originalRotation = garageMesh.rotation.clone();
            }
            
            // Garage door tilts up on X axis (like overhead door)
            const rotationAmount = -Math.PI / 3;  // -60 degrees (tilt up and back)
            const startRotX = garageMesh.rotation.x;
            const targetRotX = garageMesh.userData.originalRotation.x + rotationAmount;
            const duration = 1000;
            const startTime = Date.now();
            
            console.log('üöó Garage start rotX:', startRotX, 'target rotX:', targetRotX);

            function animateOpen() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                garageMesh.rotation.x = startRotX + (targetRotX - startRotX) * easeProgress;

                if (progress < 1) {
                    requestAnimationFrame(animateOpen);
                } else {
                    garageAnimating = false;
                    garageOpen = true;
                    console.log('‚úÖ Garage opened at rotX:', garageMesh.rotation.x);
                }
            }

            animateOpen();
        }

        function closeGarage() {
            if (!garageMesh || garageAnimating || !garageOpen) return;

            console.log('üöó Closing garage (tilting down)...');
            garageAnimating = true;

            const targetRotX = garageMesh.userData.originalRotation?.x || 0;
            const startRotX = garageMesh.rotation.x;
            const duration = 1000;
            const startTime = Date.now();

            function animateClose() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                garageMesh.rotation.x = startRotX + (targetRotX - startRotX) * easeProgress;

                if (progress < 1) {
                    requestAnimationFrame(animateClose);
                } else {
                    garageMesh.rotation.x = targetRotX;
                    garageAnimating = false;
                    garageOpen = false;
                    console.log('‚úÖ Garage closed');
                }
            }

            animateClose();
        }

        function openWindowMesh(windowMesh) {
            if (!windowMesh || windowMesh.userData.isAnimating) return;
            if (windowMesh.userData.isOpen) return;

            console.log('ü™ü Opening window:', windowMesh.name);
            windowMesh.userData.isAnimating = true;

            // Create pivot group if not exists
            if (!windowMesh.userData.pivotGroup) {
                // Get window's world position and dimensions
                const bbox = new THREE.Box3().setFromObject(windowMesh);
                const size = new THREE.Vector3();
                const center = new THREE.Vector3();
                bbox.getSize(size);
                bbox.getCenter(center);
                
                console.log('ü™ü Window bbox center:', center.x.toFixed(3), center.y.toFixed(3), center.z.toFixed(3));
                console.log('ü™ü Window size:', size.x.toFixed(3), size.y.toFixed(3), size.z.toFixed(3));
                
                // Find hinge edge - use the larger horizontal dimension for width
                const hingePos = center.clone();
                
                // Determine which axis is the width (larger of X or Z)
                if (size.z > size.x) {
                    // Width is on Z axis, hinge at +Z edge
                    hingePos.z += size.z / 2;
                } else {
                    // Width is on X axis, hinge at +X edge
                    hingePos.x += size.x / 2;
                }
                
                console.log('ü™ü Hinge position:', hingePos.x.toFixed(3), hingePos.y.toFixed(3), hingePos.z.toFixed(3));
                
                // Create pivot group at hinge position
                const pivotGroup = new THREE.Group();
                pivotGroup.position.copy(hingePos);
                scene.add(pivotGroup);
                
                // Reparent window to pivot group (preserves world transform)
                pivotGroup.attach(windowMesh);
                
                // Store references
                windowMesh.userData.pivotGroup = pivotGroup;
            }
            
            const pivotGroup = windowMesh.userData.pivotGroup;
            const startRotY = pivotGroup.rotation.y;
            // upper_window_mesh_1 opens at +45¬∞, others at -45¬∞
            const targetRotY = windowMesh.name === 'upper_window_mesh_1' ? Math.PI / 4 : -Math.PI / 4;
            const duration = 500;
            const startTime = Date.now();

            function animateOpen() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                pivotGroup.rotation.y = startRotY + (targetRotY - startRotY) * easeProgress;

                if (progress < 1) {
                    requestAnimationFrame(animateOpen);
                } else {
                    windowMesh.userData.isAnimating = false;
                    windowMesh.userData.isOpen = true;
                    console.log('‚úÖ Window opened:', windowMesh.name);
                }
            }

            animateOpen();
        }

        function closeWindowMesh(windowMesh) {
            if (!windowMesh || windowMesh.userData.isAnimating) return;
            if (!windowMesh.userData.isOpen) return;

            console.log('ü™ü Closing window:', windowMesh.name);
            windowMesh.userData.isAnimating = true;

            const pivotGroup = windowMesh.userData.pivotGroup;
            if (!pivotGroup) {
                windowMesh.userData.isAnimating = false;
                return;
            }
            
            const startRotY = pivotGroup.rotation.y;
            const targetRotY = 0;
            const duration = 500;
            const startTime = Date.now();

            function animateClose() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                pivotGroup.rotation.y = startRotY + (targetRotY - startRotY) * easeProgress;

                if (progress < 1) {
                    requestAnimationFrame(animateClose);
                } else {
                    pivotGroup.rotation.y = 0;
                    windowMesh.userData.isAnimating = false;
                    windowMesh.userData.isOpen = false;
                    console.log('‚úÖ Window closed:', windowMesh.name);
                }
            }

            animateClose();
        }

        function openAllWindows() {
            if (windowMeshes.length === 0) findWindows();
            windowMeshes.forEach(w => openWindowMesh(w));
            windowsOpen = true;
        }

        function closeAllWindows() {
            windowMeshes.forEach(w => closeWindowMesh(w));
            windowsOpen = false;
        }

        function toggleAllWindows() {
            if (windowMeshes.length === 0) findWindows();
            if (windowsOpen) {
                closeAllWindows();
            } else {
                openAllWindows();
            }
        }
        
        // Toggle interior lights on/off
        let lightsOn = true;
        function toggleLights() {
            lightsOn = !lightsOn;
            
            // Toggle point lights
            if (pointLight1) pointLight1.intensity = lightsOn ? 0.8 : 0;
            if (pointLight2) pointLight2.intensity = lightsOn ? 0.5 : 0;
            
            // Adjust ambient light
            if (ambientLight) {
                ambientLight.intensity = lightsOn ? 0.6 : 0.2;
            }
            
            // Make windows glow when lights are on at night
            if (!lightsOn) {
                windowMeshes.forEach(w => {
                    if (w.material) {
                        w.material.emissive = new THREE.Color(0x000000);
                        w.material.emissiveIntensity = 0;
                    }
                });
            } else {
                const hour = isAutoTimeEnabled ? new Date().getHours() : manualTimeOfDay;
                const isNight = hour >= 18 || hour < 6;
                if (isNight) {
                    windowMeshes.forEach(w => {
                        if (w.material) {
                            w.material.emissive = new THREE.Color(0xFFDD88);
                            w.material.emissiveIntensity = 0.5;
                        }
                    });
                }
            }
            
            console.log('üí° Lights:', lightsOn ? 'ON' : 'OFF');
        }

        function openDoor() {
            if (!doorMesh) {
                if (!findDoor()) {
                    console.log('‚ùå Cannot animate door - mesh not found. Searching all meshes...');
                    Object.entries(roomMeshes).forEach(([name, mesh]) => {
                        if (name.toLowerCase().includes('door') && !name.toLowerCase().includes('garage')) {
                            doorMesh = mesh;
                            console.log('üö™ Found alternative door mesh:', name);
                        }
                    });
                    if (!doorMesh) return;
                }
            }

            if (doorAnimating || doorOpen) {
                console.log('‚ö†Ô∏è Door already open or animating');
                return;
            }

            console.log('üö™ Opening door:', doorMesh.name);
            doorAnimating = true;

            // Create pivot group if not exists
            if (!doorMesh.userData.pivotGroup) {
                // Get door's world position and dimensions
                const worldPos = new THREE.Vector3();
                doorMesh.getWorldPosition(worldPos);
                
                const bbox = new THREE.Box3().setFromObject(doorMesh);
                const size = new THREE.Vector3();
                const center = new THREE.Vector3();
                bbox.getSize(size);
                bbox.getCenter(center);
                
                console.log('üö™ Door world pos:', worldPos.x.toFixed(3), worldPos.y.toFixed(3), worldPos.z.toFixed(3));
                console.log('üö™ Door bbox center:', center.x.toFixed(3), center.y.toFixed(3), center.z.toFixed(3));
                console.log('üö™ Door size:', size.x.toFixed(3), size.y.toFixed(3), size.z.toFixed(3));
                
                // Find hinge edge - it's at center + half width on the appropriate axis
                // Door width is 0.6, so hinge is 0.3 from center
                // We need to figure out which direction based on door orientation
                const hingePos = center.clone();
                
                // Try +Z first (right edge when looking at door)
                hingePos.z += size.z / 2;
                
                console.log('üö™ Hinge position:', hingePos.x.toFixed(3), hingePos.y.toFixed(3), hingePos.z.toFixed(3));
                
                // Create pivot group at hinge position
                const pivotGroup = new THREE.Group();
                pivotGroup.position.copy(hingePos);
                scene.add(pivotGroup);
                
                // Store door's original parent and world matrix
                const originalParent = doorMesh.parent;
                const doorWorldMatrix = doorMesh.matrixWorld.clone();
                
                // Reparent door to pivot group
                pivotGroup.attach(doorMesh);
                
                // Store references
                doorMesh.userData.pivotGroup = pivotGroup;
                doorMesh.userData.originalParent = originalParent;
                doorMesh.userData.originalWorldMatrix = doorWorldMatrix;
                doorMesh.userData.hingePos = hingePos.clone();
            }
            
            const pivotGroup = doorMesh.userData.pivotGroup;
            const startRotY = pivotGroup.rotation.y;
            const targetRotY = -Math.PI / 2;  // -90 degrees
            const duration = 800;
            const startTime = Date.now();

            function animateOpen() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                pivotGroup.rotation.y = startRotY + (targetRotY - startRotY) * easeProgress;

                if (progress < 1) {
                    requestAnimationFrame(animateOpen);
                } else {
                    doorAnimating = false;
                    doorOpen = true;
                    console.log('‚úÖ Door opened');
                }
            }

            animateOpen();
        }

        function closeDoor() {
            if (!doorMesh || doorAnimating || !doorOpen) {
                return;
            }

            console.log('üö™ Closing door...');
            doorAnimating = true;

            const pivotGroup = doorMesh.userData.pivotGroup;
            if (!pivotGroup) {
                doorAnimating = false;
                return;
            }
            
            const startRotY = pivotGroup.rotation.y;
            const targetRotY = 0;
            const duration = 800;
            const startTime = Date.now();

            function animateClose() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                pivotGroup.rotation.y = startRotY + (targetRotY - startRotY) * easeProgress;

                if (progress < 1) {
                    requestAnimationFrame(animateClose);
                } else {
                    pivotGroup.rotation.y = 0;
                    doorAnimating = false;
                    doorOpen = false;
                    console.log('‚úÖ Door closed');
                }
            }

            animateClose();
        }

        // Generic mesh animation for rooms/objects
        function animateMesh(mesh, highlight = false) {
            if (!mesh || !mesh.material) return;

            const originalColor = mesh.userData.originalColor || mesh.material.color.clone();
            const targetColor = new THREE.Color(highlight ? 0x00ff00 : 0xffffff);
            const duration = 500;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                mesh.material.color.lerpColors(originalColor, targetColor, progress);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Reset after highlight
                    setTimeout(() => {
                        mesh.material.color.copy(originalColor);
                    }, 300);
                }
            }

            animate();
        }

        // ============================================
        // RGB THEME BACKGROUND & DAY/NIGHT CYCLE SYSTEM
        // ============================================
        
        // Set background color from Flutter (RGB values)
        function setBackgroundColor(r, g, b) {
            if (!scene) return;
            const color = new THREE.Color(r / 255, g / 255, b / 255);
            scene.background = color;
            console.log(`üé® Background color set to RGB(${r}, ${g}, ${b})`);
        }
        
        // Set background color from hex
        function setBackgroundColorHex(hexColor) {
            if (!scene) return;
            scene.background = new THREE.Color(hexColor);
            console.log(`üé® Background color set to ${hexColor}`);
        }
        
        // Initialize day/night cycle with sun and moon
        function initializeDayNightCycle() {
            // Create sun (larger yellow sphere with glow effect)
            const sunGeometry = new THREE.SphereGeometry(12, 64, 64);
            const sunMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFDD00,
                emissive: 0xFFAA00,
                emissiveIntensity: 2.0,
                roughness: 0.1,
                metalness: 0.0
            });
            sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.set(150, 80, 0);
            scene.add(sunMesh);
            
            // Sun glow effect (outer halo)
            const sunGlowGeometry = new THREE.SphereGeometry(18, 32, 32);
            const sunGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFDD44,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
            sunMesh.add(sunGlow);
            
            // Sun light (directional, warm)
            sunLight = new THREE.DirectionalLight(0xFFFFCC, 1.8);
            sunLight.position.copy(sunMesh.position);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
            
            // Create moon (larger pale sphere with crater texture simulation)
            const moonGeometry = new THREE.SphereGeometry(8, 64, 64);
            const moonMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xDDDDEE,
                emissive: 0x8888AA,
                emissiveIntensity: 0.5,
                roughness: 0.8,
                metalness: 0.1
            });
            moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
            moonMesh.position.set(-150, -80, 0);
            scene.add(moonMesh);
            
            // Moon glow effect (subtle outer halo)
            const moonGlowGeometry = new THREE.SphereGeometry(11, 32, 32);
            const moonGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xAAAACC,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide
            });
            const moonGlow = new THREE.Mesh(moonGlowGeometry, moonGlowMaterial);
            moonMesh.add(moonGlow);
            
            // Moon light (directional, cool blue)
            moonLight = new THREE.DirectionalLight(0x6677BB, 0.4);
            moonLight.position.copy(moonMesh.position);
            scene.add(moonLight);
            
            // Create ground plane at yard level (will be adjusted when model loads)
            const groundGeometry = new THREE.PlaneGeometry(500, 500);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x7CCD7C,  // Light grass green (matches theme)
                roughness: 0.9,
                metalness: 0.0
            });
            groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.position.y = 0;  // At ground level, adjusted when model loads
            groundPlane.receiveShadow = true;
            scene.add(groundPlane);
            
            // Create stars for night sky
            createStars();
            
            console.log('üåÖ Day/Night cycle initialized with sun, moon, ground, and stars');
        }
        
        // Update sun/moon positions based on time of day (0-24)
        function updateDayNightCycle(timeOfDay = null) {
            if (!sunMesh || !moonMesh) {
                initializeDayNightCycle();
            }
            
            // Use real time if autoTime is enabled
            let hour = timeOfDay;
            if (hour === null) {
                if (isAutoTimeEnabled) {
                    const now = new Date();
                    hour = now.getHours() + now.getMinutes() / 60;
                } else {
                    hour = manualTimeOfDay;
                }
            }
            
            // Calculate sun position (rises at 6, sets at 18)
            // Convert hour to radians (0-24 -> 0-2œÄ)
            const sunAngle = ((hour - 6) / 12) * Math.PI;
            const orbitRadius = 180; // Much larger orbit for better visual
            
            // Sun position on circular path
            const sunX = Math.cos(sunAngle) * orbitRadius;
            const sunY = Math.sin(sunAngle) * orbitRadius * 0.6 + 30;
            const sunZ = Math.sin(sunAngle) * orbitRadius * 0.3;
            
            sunMesh.position.set(sunX, Math.max(sunY, -50), sunZ);
            sunLight.position.copy(sunMesh.position);
            
            // Moon is opposite to sun with larger separation
            moonMesh.position.set(-sunX, -sunY + 60, -sunZ);
            moonLight.position.copy(moonMesh.position);
            
            // Calculate day/night intensity (0 = midnight, 1 = noon)
            const dayProgress = Math.sin(sunAngle);
            const dayIntensity = Math.max(0, dayProgress);
            const nightIntensity = Math.max(0, -dayProgress);
            
            // Update light intensities
            sunLight.intensity = dayIntensity * 1.5;
            moonLight.intensity = nightIntensity * 0.4;
            
            // Update sun/moon visibility based on actual time
            // Sun visible from 6am to 6pm (hours 6-18)
            // Moon visible from 6pm to 6am (hours 18-6)
            const isSunTime = hour >= 6 && hour < 18;
            const isMoonTime = hour >= 18 || hour < 6;
            sunMesh.visible = isSunTime;
            moonMesh.visible = isMoonTime;
            
            // Update navbar time display with color
            const navbarTime = document.getElementById('navbar-time');
            const displayHour = Math.floor(hour);
            const displayMin = Math.floor((hour % 1) * 60);
            const timeStr = `${displayHour.toString().padStart(2, '0')}:${displayMin.toString().padStart(2, '0')}`;
            const timeColor = getTimeColor(hour);
            
            if (navbarTime) {
                navbarTime.textContent = timeStr;
                navbarTime.style.color = timeColor;
            }
            
            // Sync drawer time display
            const drawerTime = document.getElementById('drawer-time');
            if (drawerTime) {
                drawerTime.textContent = timeStr;
                drawerTime.style.color = timeColor;
            }
            
            // Sync time slider display
            const timeDisplay = document.getElementById('time-display');
            if (timeDisplay) {
                timeDisplay.textContent = timeStr;
            }
            
            // Update stars visibility
            updateStarsVisibility(hour);
            
            // Update ambient light based on time
            if (ambientLight) {
                const ambientDay = new THREE.Color(0xFFFFFF);
                const ambientNight = new THREE.Color(0x222244);
                ambientLight.color.lerpColors(ambientNight, ambientDay, dayIntensity * 0.8 + 0.2);
                ambientLight.intensity = 0.4 + dayIntensity * 0.8;
            }
            
            // Update ground color based on time
            if (groundPlane && groundPlane.material) {
                const groundDay = new THREE.Color(0x5a9a5a);   // Bright grass green
                const groundNight = new THREE.Color(0x1a3a1a); // Dark grass
                groundPlane.material.color.lerpColors(groundNight, groundDay, dayIntensity * 0.7 + 0.3);
            }
            
            // Update sky color based on time
            updateSkyColor(hour, dayIntensity);
        }
        
        // Update sky/background color based on time
        function updateSkyColor(hour, dayIntensity) {
            if (!scene) return;
            
            // Define sky colors for different times (evening colors are less dramatic)
            const nightColor = new THREE.Color(0x0a0a1a);     // Dark blue/black
            const dawnColor = new THREE.Color(0xE8A070);      // Soft peach
            const morningColor = new THREE.Color(0x87CEEB);   // Light blue
            const noonColor = new THREE.Color(0x6BB3F8);      // Clear blue
            const afternoonColor = new THREE.Color(0x7CB8E8); // Slightly warmer blue
            const sunsetColor = new THREE.Color(0xC87850);    // Soft sunset orange
            const duskColor = new THREE.Color(0x2A2050);      // Dark purple
            
            let skyColor = new THREE.Color();
            
            if (hour < 5 || hour >= 21) {
                // Night (9pm - 5am)
                skyColor.copy(nightColor);
            } else if (hour < 7) {
                // Dawn (5-7am)
                const t = (hour - 5) / 2;
                skyColor.lerpColors(nightColor, dawnColor, t);
            } else if (hour < 9) {
                // Early morning (7-9am)
                const t = (hour - 7) / 2;
                skyColor.lerpColors(dawnColor, morningColor, t);
            } else if (hour < 15) {
                // Day (9am-3pm)
                const t = (hour - 9) / 6;
                skyColor.lerpColors(morningColor, noonColor, t);
            } else if (hour < 17) {
                // Afternoon (3-5pm)
                const t = (hour - 15) / 2;
                skyColor.lerpColors(noonColor, afternoonColor, t);
            } else if (hour < 19) {
                // Sunset (5-7pm)
                const t = (hour - 17) / 2;
                skyColor.lerpColors(afternoonColor, sunsetColor, t);
            } else {
                // Dusk to night (7-9pm)
                const t = (hour - 19) / 2;
                skyColor.lerpColors(sunsetColor, duskColor, t);
            }
            
            scene.background = skyColor;
        }
        
        // Set time of day manually (0-24)
        function setTimeOfDay(hour) {
            manualTimeOfDay = Math.max(0, Math.min(24, hour));
            isAutoTimeEnabled = false;
            updateDayNightCycle(manualTimeOfDay);
            console.log(`‚è∞ Time set to ${manualTimeOfDay}:00`);
        }
        
        // Enable real-time auto mode
        function enableAutoTime() {
            isAutoTimeEnabled = true;
            console.log('üïê Auto time mode enabled');
        }
        
        // Get current time of day
        function getCurrentTimeOfDay() {
            if (isAutoTimeEnabled) {
                const now = new Date();
                return now.getHours() + now.getMinutes() / 60;
            }
            return manualTimeOfDay;
        }

        // Expose functions to global scope for Flutter to call
        window.resetCamera = resetCamera;
        window.openDoor = openDoor;
        window.closeDoor = closeDoor;
        window.toggleDoor = toggleDoor;
        window.openGarage = openGarage;
        window.closeGarage = closeGarage;
        window.toggleGarage = toggleGarage;
        window.openAllWindows = openAllWindows;
        window.closeAllWindows = closeAllWindows;
        window.toggleAllWindows = toggleAllWindows;
        window.toggleLights = toggleLights;
        window.toggleInteractiveElement = toggleInteractiveElement;
        window.updateAlarms = updateAlarms;
        window.loadModelFromBase64 = loadModelFromBase64;
        // Day/Night cycle and background functions
        window.setBackgroundColor = setBackgroundColor;
        window.setBackgroundColorHex = setBackgroundColorHex;
        window.setTimeOfDay = setTimeOfDay;
        window.enableAutoTime = enableAutoTime;
        window.getCurrentTimeOfDay = getCurrentTimeOfDay;
        window.updateDayNightCycle = updateDayNightCycle;
        window.initializeDayNightCycle = initializeDayNightCycle;
        // Selection panel functions
        window.showSelectionPanel = showSelectionPanel;
        window.hideSelectionPanel = hideSelectionPanel;
        window.formatMeshName = formatMeshName;

        // Initialize the scene
        init();
        
        console.log('üì± Touch controls: One finger rotates, two fingers zoom');
    </script>
</body>
</html>